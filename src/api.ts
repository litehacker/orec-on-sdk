/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * OREC.ON.API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ",",
  ssv: " ",
  tsv: "\t",
  pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration = new Configuration();

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = isomorphicFetch
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name = "RequiredError";
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 *
 * @export
 * @interface ACconnectorType
 */
export interface ACconnectorType {
  /**
   *
   * @type {number}
   * @memberof ACconnectorType
   */
  id?: number;
}
/**
 *
 * @export
 * @interface AuthAppLoginResponse
 */
export interface AuthAppLoginResponse {
  /**
   *
   * @type {string}
   * @memberof AuthAppLoginResponse
   */
  callbackCorrelationId?: string;
  /**
   *
   * @type {string}
   * @memberof AuthAppLoginResponse
   */
  uiRequestId?: string;
  /**
   *
   * @type {string}
   * @memberof AuthAppLoginResponse
   */
  authAppLoginResponseType?: AuthAppLoginResponse.AuthAppLoginResponseTypeEnum;
  /**
   *
   * @type {string}
   * @memberof AuthAppLoginResponse
   */
  personNumber?: string;
  /**
   *
   * @type {string}
   * @memberof AuthAppLoginResponse
   */
  fullname?: string;
  /**
   *
   * @type {string}
   * @memberof AuthAppLoginResponse
   */
  eidToken?: string;
}

/**
 * @export
 * @namespace AuthAppLoginResponse
 */
export namespace AuthAppLoginResponse {
  /**
   * @export
   * @enum {string}
   */
  export enum AuthAppLoginResponseTypeEnum {
    Failure = <any>"Failure",
    Success = <any>"Success",
    Cancelled = <any>"Cancelled",
    Error = <any>"Error",
  }
}
/**
 *
 * @export
 * @interface AuthAppVerificationCodeResponse
 */
export interface AuthAppVerificationCodeResponse {
  /**
   *
   * @type {string}
   * @memberof AuthAppVerificationCodeResponse
   */
  uiRequestId?: string;
  /**
   *
   * @type {string}
   * @memberof AuthAppVerificationCodeResponse
   */
  callbackCorrelationId?: string;
  /**
   *
   * @type {string}
   * @memberof AuthAppVerificationCodeResponse
   */
  verificationCode?: string;
}
/**
 *
 * @export
 * @interface AuthCRMTokenLoginResponse
 */
export interface AuthCRMTokenLoginResponse {
  /**
   *
   * @type {string}
   * @memberof AuthCRMTokenLoginResponse
   */
  callbackCorrelationId?: string;
  /**
   *
   * @type {boolean}
   * @memberof AuthCRMTokenLoginResponse
   */
  isCRMValidToken?: boolean;
  /**
   *
   * @type {string}
   * @memberof AuthCRMTokenLoginResponse
   */
  userName?: string;
}
/**
 *
 * @export
 * @interface AuthPhoneNumberSIMLoginResponse
 */
export interface AuthPhoneNumberSIMLoginResponse {
  /**
   *
   * @type {string}
   * @memberof AuthPhoneNumberSIMLoginResponse
   */
  sagaId?: string;
  /**
   *
   * @type {string}
   * @memberof AuthPhoneNumberSIMLoginResponse
   */
  callbackCorrelationId?: string;
  /**
   *
   * @type {string}
   * @memberof AuthPhoneNumberSIMLoginResponse
   */
  authPhoneNumberSIMLoginResponseType?: AuthPhoneNumberSIMLoginResponse.AuthPhoneNumberSIMLoginResponseTypeEnum;
  /**
   *
   * @type {string}
   * @memberof AuthPhoneNumberSIMLoginResponse
   */
  phoneNumber?: string;
  /**
   *
   * @type {string}
   * @memberof AuthPhoneNumberSIMLoginResponse
   */
  personNumber?: string;
  /**
   *
   * @type {string}
   * @memberof AuthPhoneNumberSIMLoginResponse
   */
  fullname?: string;
  /**
   *
   * @type {string}
   * @memberof AuthPhoneNumberSIMLoginResponse
   */
  eidToken?: string;
}

/**
 * @export
 * @namespace AuthPhoneNumberSIMLoginResponse
 */
export namespace AuthPhoneNumberSIMLoginResponse {
  /**
   * @export
   * @enum {string}
   */
  export enum AuthPhoneNumberSIMLoginResponseTypeEnum {
    Failure = <any>"Failure",
    Success = <any>"Success",
    Cancelled = <any>"Cancelled",
    Error = <any>"Error",
  }
}
/**
 *
 * @export
 * @interface BusClaimDocumentResponse
 */
export interface BusClaimDocumentResponse {
  /**
   *
   * @type {string}
   * @memberof BusClaimDocumentResponse
   */
  callbackCorrelationId?: string;
  /**
   *
   * @type {string}
   * @memberof BusClaimDocumentResponse
   */
  documentReferenceToken?: string;
  /**
   *
   * @type {string}
   * @memberof BusClaimDocumentResponse
   */
  fileId?: string;
}
/**
 *
 * @export
 * @interface BusClaimsResponse
 */
export interface BusClaimsResponse {
  /**
   *
   * @type {string}
   * @memberof BusClaimsResponse
   */
  callbackCorrelationId?: string;
  /**
   *
   * @type {Array<Claim>}
   * @memberof BusClaimsResponse
   */
  claims?: Array<Claim>;
  /**
   *
   * @type {Date}
   * @memberof BusClaimsResponse
   */
  dateFrom?: Date;
  /**
   *
   * @type {Date}
   * @memberof BusClaimsResponse
   */
  dateTo?: Date;
}
/**
 *
 * @export
 * @interface BusCollectionLetterDocumentResponse
 */
export interface BusCollectionLetterDocumentResponse {
  /**
   *
   * @type {string}
   * @memberof BusCollectionLetterDocumentResponse
   */
  callbackCorrelationId?: string;
  /**
   *
   * @type {string}
   * @memberof BusCollectionLetterDocumentResponse
   */
  documentReferenceToken?: string;
  /**
   *
   * @type {string}
   * @memberof BusCollectionLetterDocumentResponse
   */
  fileId?: string;
  /**
   *
   * @type {string}
   * @memberof BusCollectionLetterDocumentResponse
   */
  stage?: string;
}
/**
 *
 * @export
 * @interface BusCustomerStatementResponse
 */
export interface BusCustomerStatementResponse {
  /**
   *
   * @type {string}
   * @memberof BusCustomerStatementResponse
   */
  callbackCorrelationId?: string;
  /**
   *
   * @type {CustomerStatement}
   * @memberof BusCustomerStatementResponse
   */
  customerStatement?: CustomerStatement;
}
/**
 *
 * @export
 * @interface BusInvoiceDocumentResponse
 */
export interface BusInvoiceDocumentResponse {
  /**
   *
   * @type {string}
   * @memberof BusInvoiceDocumentResponse
   */
  callbackCorrelationId?: string;
  /**
   *
   * @type {string}
   * @memberof BusInvoiceDocumentResponse
   */
  documentReferenceToken?: string;
  /**
   *
   * @type {string}
   * @memberof BusInvoiceDocumentResponse
   */
  fileId?: string;
}
/**
 *
 * @export
 * @interface BusInvoicesResponse
 */
export interface BusInvoicesResponse {
  /**
   *
   * @type {string}
   * @memberof BusInvoicesResponse
   */
  callbackCorrelationId?: string;
  /**
   *
   * @type {Array<Invoice>}
   * @memberof BusInvoicesResponse
   */
  invoices?: Array<Invoice>;
  /**
   *
   * @type {Date}
   * @memberof BusInvoicesResponse
   */
  dateFrom?: Date;
  /**
   *
   * @type {Date}
   * @memberof BusInvoicesResponse
   */
  dateTo?: Date;
}
/**
 *
 * @export
 * @interface BusOceanTokenAuthResponse
 */
export interface BusOceanTokenAuthResponse {
  /**
   *
   * @type {string}
   * @memberof BusOceanTokenAuthResponse
   */
  requestId?: string;
  /**
   *
   * @type {DuskyUserInfo}
   * @memberof BusOceanTokenAuthResponse
   */
  userInfo?: DuskyUserInfo;
}
/**
 *
 * @export
 * @interface BusOnPaymentsGetCheckoutPageResponse
 */
export interface BusOnPaymentsGetCheckoutPageResponse {
  /**
   *
   * @type {string}
   * @memberof BusOnPaymentsGetCheckoutPageResponse
   */
  formID?: string;
  /**
   *
   * @type {string}
   * @memberof BusOnPaymentsGetCheckoutPageResponse
   */
  callbackCorrelationId?: string;
  /**
   *
   * @type {string}
   * @memberof BusOnPaymentsGetCheckoutPageResponse
   */
  checkOutPageUrl?: string;
  /**
   *
   * @type {boolean}
   * @memberof BusOnPaymentsGetCheckoutPageResponse
   */
  isError?: boolean;
}
/**
 *
 * @export
 * @interface BusOnPaymentsGetResultForCheckoutPageResponse
 */
export interface BusOnPaymentsGetResultForCheckoutPageResponse {
  /**
   *
   * @type {string}
   * @memberof BusOnPaymentsGetResultForCheckoutPageResponse
   */
  formID?: string;
  /**
   *
   * @type {string}
   * @memberof BusOnPaymentsGetResultForCheckoutPageResponse
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof BusOnPaymentsGetResultForCheckoutPageResponse
   */
  callbackCorrelationId?: string;
}
/**
 *
 * @export
 * @interface BusPropertiesResponse
 */
export interface BusPropertiesResponse {
  /**
   *
   * @type {string}
   * @memberof BusPropertiesResponse
   */
  callbackCorrelationId?: string;
  /**
   *
   * @type {Array<MeteringPointInfo>}
   * @memberof BusPropertiesResponse
   */
  notServicedByON?: Array<MeteringPointInfo>;
  /**
   *
   * @type {Array<MeteringPointInfo>}
   * @memberof BusPropertiesResponse
   */
  alreadyServicedByON?: Array<MeteringPointInfo>;
}
/**
 *
 * @export
 * @interface Claim
 */
export interface Claim {
  /**
   *
   * @type {string}
   * @memberof Claim
   */
  claimNo?: string;
  /**
   *
   * @type {string}
   * @memberof Claim
   */
  ssn?: string;
  /**
   *
   * @type {string}
   * @memberof Claim
   */
  ssnClaimant?: string;
  /**
   *
   * @type {string}
   * @memberof Claim
   */
  claimType?: Claim.ClaimTypeEnum;
  /**
   *
   * @type {string}
   * @memberof Claim
   */
  paymentMethod?: Claim.PaymentMethodEnum;
  /**
   *
   * @type {string}
   * @memberof Claim
   */
  paymentMethodDescription?: string;
  /**
   *
   * @type {Date}
   * @memberof Claim
   */
  deadlineDate?: Date;
  /**
   *
   * @type {Date}
   * @memberof Claim
   */
  dueDate?: Date;
  /**
   *
   * @type {boolean}
   * @memberof Claim
   */
  isPaid?: boolean;
  /**
   *
   * @type {number}
   * @memberof Claim
   */
  originalAmount?: number;
  /**
   *
   * @type {number}
   * @memberof Claim
   */
  currentAmount?: number;
  /**
   *
   * @type {number}
   * @memberof Claim
   */
  otherCost?: number;
  /**
   *
   * @type {number}
   * @memberof Claim
   */
  latePaymentFee?: number;
  /**
   *
   * @type {number}
   * @memberof Claim
   */
  interestRates?: number;
  /**
   *
   * @type {number}
   * @memberof Claim
   */
  totalPayment?: number;
  /**
   *
   * @type {string}
   * @memberof Claim
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof Claim
   */
  paymentProcessDescription?: string;
  /**
   *
   * @type {string}
   * @memberof Claim
   */
  noteNumber?: string;
  /**
   *
   * @type {string}
   * @memberof Claim
   */
  referralClaim?: string;
  /**
   *
   * @type {Array<CollectionLetter>}
   * @memberof Claim
   */
  collectionLetters?: Array<CollectionLetter>;
  /**
   *
   * @type {string}
   * @memberof Claim
   */
  documentReferenceToken?: string;
  /**
   *
   * @type {string}
   * @memberof Claim
   */
  companyId?: string;
}

/**
 * @export
 * @namespace Claim
 */
export namespace Claim {
  /**
   * @export
   * @enum {string}
   */
  export enum ClaimTypeEnum {
    Unknown = <any>"Unknown",
    AN = <any>"AN",
    DB = <any>"DB",
    EF = <any>"EF",
    G = <any>"G",
    GA = <any>"GA",
    GD = <any>"GD",
    GK = <any>"GK",
    GS = <any>"GS",
    LG = <any>"LG",
    LX = <any>"LX",
    MA = <any>"MA",
    MT = <any>"MT",
    RK = <any>"RK",
    RR = <any>"RR",
    VE = <any>"VE",
    _04 = <any>"_04",
    _05 = <any>"_05",
    _07 = <any>"_07",
    _11 = <any>"_11",
    _13 = <any>"_13",
    _16 = <any>"_16",
    _30 = <any>"_30",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum PaymentMethodEnum {
    Unknown = <any>"Unknown",
    AN = <any>"AN",
    BSL = <any>"BSL",
    BSS = <any>"BSS",
    BS1 = <any>"BS1",
    BS2 = <any>"BS2",
    BS3 = <any>"BS3",
    BS4 = <any>"BS4",
    BS5 = <any>"BS5",
    BS6 = <any>"BS6",
    BS7 = <any>"BS7",
    BDL = <any>"BDL",
    BDS = <any>"BDS",
    BD1 = <any>"BD1",
    BD2 = <any>"BD2",
    BD3 = <any>"BD3",
    BD4 = <any>"BD4",
    BD5 = <any>"BD5",
    BD6 = <any>"BD6",
    BD7 = <any>"BD7",
    BG = <any>"BG",
    BRG = <any>"BRG",
    DB = <any>"DB",
    EFS = <any>"EFS",
    GA = <any>"GA",
    GS = <any>"GS",
    GV = <any>"GV",
    HA = <any>"HA",
    HG = <any>"HG",
    HP = <any>"HP",
    K = <any>"K",
    LG = <any>"LG",
    LGX = <any>"LGX",
    MA = <any>"MA",
    MT = <any>"MT",
    N = <any>"N",
    NE = <any>"NE",
    RK = <any>"RK",
    RO = <any>"RO",
    RR = <any>"RR",
    RS = <any>"RS",
    RV = <any>"RV",
    SD = <any>"SD",
    VE = <any>"VE",
    _12 = <any>"_12",
    _13 = <any>"_13",
  }
}
/**
 *
 * @export
 * @interface CollectionLetter
 */
export interface CollectionLetter {
  /**
   *
   * @type {string}
   * @memberof CollectionLetter
   */
  claimNo?: string;
  /**
   *
   * @type {string}
   * @memberof CollectionLetter
   */
  stageCode?: string;
  /**
   *
   * @type {string}
   * @memberof CollectionLetter
   */
  ssn?: string;
  /**
   *
   * @type {Date}
   * @memberof CollectionLetter
   */
  postingDate?: Date;
}
/**
 *
 * @export
 * @interface CreditAllocation
 */
export interface CreditAllocation {
  /**
   *
   * @type {string}
   * @memberof CreditAllocation
   */
  invoiceNumber?: string;
  /**
   *
   * @type {string}
   * @memberof CreditAllocation
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof CreditAllocation
   */
  meteringPointName?: string;
  /**
   *
   * @type {Date}
   * @memberof CreditAllocation
   */
  createdDate?: Date;
  /**
   *
   * @type {Date}
   * @memberof CreditAllocation
   */
  paymentDate?: Date;
  /**
   *
   * @type {number}
   * @memberof CreditAllocation
   */
  amount?: number;
  /**
   *
   * @type {string}
   * @memberof CreditAllocation
   */
  creditAllocationType?: CreditAllocation.CreditAllocationTypeEnum;
}

/**
 * @export
 * @namespace CreditAllocation
 */
export namespace CreditAllocation {
  /**
   * @export
   * @enum {string}
   */
  export enum CreditAllocationTypeEnum {
    Invoice = <any>"Invoice",
    Credit = <any>"Credit",
    Unknown = <any>"Unknown",
  }
}
/**
 *
 * @export
 * @interface CustomerStatement
 */
export interface CustomerStatement {
  /**
   *
   * @type {Array<Transaction>}
   * @memberof CustomerStatement
   */
  transactions?: Array<Transaction>;
  /**
   *
   * @type {string}
   * @memberof CustomerStatement
   */
  requestId?: string;
  /**
   *
   * @type {Date}
   * @memberof CustomerStatement
   */
  dateFrom?: Date;
  /**
   *
   * @type {Date}
   * @memberof CustomerStatement
   */
  dateTo?: Date;
  /**
   *
   * @type {string}
   * @memberof CustomerStatement
   */
  customerPersonNumber?: string;
  /**
   *
   * @type {string}
   * @memberof CustomerStatement
   */
  customerName?: string;
  /**
   *
   * @type {string}
   * @memberof CustomerStatement
   */
  customerStreet?: string;
  /**
   *
   * @type {string}
   * @memberof CustomerStatement
   */
  customerPostalCode?: string;
  /**
   *
   * @type {string}
   * @memberof CustomerStatement
   */
  customerCity?: string;
  /**
   *
   * @type {number}
   * @memberof CustomerStatement
   */
  startingBalance?: number;
  /**
   *
   * @type {number}
   * @memberof CustomerStatement
   */
  periodInvoices?: number;
  /**
   *
   * @type {number}
   * @memberof CustomerStatement
   */
  periodPayments?: number;
  /**
   *
   * @type {number}
   * @memberof CustomerStatement
   */
  periodInterestsAndFees?: number;
  /**
   *
   * @type {string}
   * @memberof CustomerStatement
   */
  companySSN?: string;
  /**
   *
   * @type {Date}
   * @memberof CustomerStatement
   */
  dateRetrieved?: Date;
}
/**
 *
 * @export
 * @interface DCconnectorType
 */
export interface DCconnectorType {
  /**
   *
   * @type {number}
   * @memberof DCconnectorType
   */
  id?: number;
}
/**
 *
 * @export
 * @interface DateTimeData
 */
export interface DateTimeData {
  /**
   *
   * @type {Date}
   * @memberof DateTimeData
   */
  time?: Date;
}
/**
 *
 * @export
 * @interface DefaultVehicle
 */
export interface DefaultVehicle {
  /**
   *
   * @type {number}
   * @memberof DefaultVehicle
   */
  id?: number;
  /**
   *
   * @type {number}
   * @memberof DefaultVehicle
   */
  userId?: number;
  /**
   *
   * @type {Version}
   * @memberof DefaultVehicle
   */
  version?: Version;
  /**
   *
   * @type {boolean}
   * @memberof DefaultVehicle
   */
  isDefaultVehicle?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof DefaultVehicle
   */
  hasDefaultCharacteristics?: boolean;
  /**
   *
   * @type {DateTimeData}
   * @memberof DefaultVehicle
   */
  inserted?: DateTimeData;
  /**
   *
   * @type {DateTimeData}
   * @memberof DefaultVehicle
   */
  updated?: DateTimeData;
}
/**
 *
 * @export
 * @interface DocumentsDeletefileBody
 */
export interface DocumentsDeletefileBody {
  /**
   *
   * @type {string}
   * @memberof DocumentsDeletefileBody
   */
  idOfSubject?: string;
  /**
   *
   * @type {string}
   * @memberof DocumentsDeletefileBody
   */
  fileId?: string;
}
/**
 *
 * @export
 * @interface DocumentsDeletefilepermanentlyBody
 */
export interface DocumentsDeletefilepermanentlyBody {
  /**
   *
   * @type {string}
   * @memberof DocumentsDeletefilepermanentlyBody
   */
  idOfSubject?: string;
  /**
   *
   * @type {string}
   * @memberof DocumentsDeletefilepermanentlyBody
   */
  fileId?: string;
}
/**
 *
 * @export
 * @interface DocumentsUploadfileBody
 */
export interface DocumentsUploadfileBody {
  /**
   *
   * @type {Blob}
   * @memberof DocumentsUploadfileBody
   */
  file?: Blob;
  /**
   *
   * @type {string}
   * @memberof DocumentsUploadfileBody
   */
  idOfSubject?: string;
  /**
   *
   * @type {string}
   * @memberof DocumentsUploadfileBody
   */
  company?: string;
  /**
   *
   * @type {string}
   * @memberof DocumentsUploadfileBody
   */
  system?: string;
  /**
   *
   * @type {Date}
   * @memberof DocumentsUploadfileBody
   */
  expiryDateOfFile?: Date;
  /**
   *
   * @type {boolean}
   * @memberof DocumentsUploadfileBody
   */
  shouldBeDeletedAfterExpiry?: boolean;
}
/**
 *
 * @export
 * @interface DuskyUserInfo
 */
export interface DuskyUserInfo {
  /**
   *
   * @type {Array<Vehicle>}
   * @memberof DuskyUserInfo
   */
  vehicles?: Array<Vehicle>;
  /**
   *
   * @type {DefaultVehicle}
   * @memberof DuskyUserInfo
   */
  defaultVehicle?: DefaultVehicle;
  /**
   *
   * @type {Array<any>}
   * @memberof DuskyUserInfo
   */
  gdprConsentVersions?: Array<any>;
  /**
   *
   * @type {Array<any>}
   * @memberof DuskyUserInfo
   */
  termsAndConditions?: Array<any>;
  /**
   *
   * @type {number}
   * @memberof DuskyUserInfo
   */
  resultCode?: number;
  /**
   *
   * @type {UserData}
   * @memberof DuskyUserInfo
   */
  userData?: UserData;
  /**
   *
   * @type {string}
   * @memberof DuskyUserInfo
   */
  kennitala?: string;
  /**
   *
   * @type {string}
   * @memberof DuskyUserInfo
   */
  lastLoginType?: DuskyUserInfo.LastLoginTypeEnum;
}

/**
 * @export
 * @namespace DuskyUserInfo
 */
export namespace DuskyUserInfo {
  /**
   * @export
   * @enum {string}
   */
  export enum LastLoginTypeEnum {
    PasswordAuthentication = <any>"PasswordAuthentication",
    CertificateAuthentication = <any>"CertificateAuthentication",
  }
}
/**
 *
 * @export
 * @interface EchoPostBody
 */
export interface EchoPostBody {
  /**
   *
   * @type {number}
   * @memberof EchoPostBody
   */
  requiredIntNumber: number;
  /**
   *
   * @type {string}
   * @memberof EchoPostBody
   */
  requiredDescription: string;
  /**
   *
   * @type {NestedEchoPostBody}
   * @memberof EchoPostBody
   */
  requiredNestedEchoPostBody: NestedEchoPostBody;
  /**
   *
   * @type {number}
   * @memberof EchoPostBody
   */
  intNumber?: number;
  /**
   *
   * @type {string}
   * @memberof EchoPostBody
   */
  description?: string;
  /**
   *
   * @type {NestedEchoPostBody}
   * @memberof EchoPostBody
   */
  nestedEchoPostBody?: NestedEchoPostBody;
}
/**
 *
 * @export
 * @interface ElectronicCredentials
 */
export interface ElectronicCredentials {
  /**
   *
   * @type {string}
   * @memberof ElectronicCredentials
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof ElectronicCredentials
   */
  nationalId: string;
  /**
   *
   * @type {string}
   * @memberof ElectronicCredentials
   */
  fullName: string;
  /**
   *
   * @type {string}
   * @memberof ElectronicCredentials
   */
  phoneNumber: string;
  /**
   *
   * @type {Date}
   * @memberof ElectronicCredentials
   */
  timeStamp: Date;
}
/**
 *
 * @export
 * @interface IDTitle
 */
export interface IDTitle {
  /**
   *
   * @type {number}
   * @memberof IDTitle
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof IDTitle
   */
  title?: string;
}
/**
 *
 * @export
 * @interface Invoice
 */
export interface Invoice {
  /**
   *
   * @type {string}
   * @memberof Invoice
   */
  invoiceNumber?: string;
  /**
   *
   * @type {string}
   * @memberof Invoice
   */
  invoiceType?: Invoice.InvoiceTypeEnum;
  /**
   *
   * @type {string}
   * @memberof Invoice
   */
  invoiceSystem?: Invoice.InvoiceSystemEnum;
  /**
   *
   * @type {string}
   * @memberof Invoice
   */
  originSystem?: Invoice.OriginSystemEnum;
  /**
   *
   * @type {string}
   * @memberof Invoice
   */
  companyId?: string;
  /**
   *
   * @type {string}
   * @memberof Invoice
   */
  meteringPointName?: string;
  /**
   *
   * @type {Date}
   * @memberof Invoice
   */
  createdDate?: Date;
  /**
   *
   * @type {Date}
   * @memberof Invoice
   */
  dueDate?: Date;
  /**
   *
   * @type {Date}
   * @memberof Invoice
   */
  paymentDate?: Date;
  /**
   *
   * @type {boolean}
   * @memberof Invoice
   */
  isPaid?: boolean;
  /**
   *
   * @type {number}
   * @memberof Invoice
   */
  amount?: number;
  /**
   *
   * @type {number}
   * @memberof Invoice
   */
  remainingAmount?: number;
  /**
   *
   * @type {string}
   * @memberof Invoice
   */
  documentReferenceToken?: string;
  /**
   *
   * @type {Array<CreditAllocation>}
   * @memberof Invoice
   */
  creditAllocations?: Array<CreditAllocation>;
}

/**
 * @export
 * @namespace Invoice
 */
export namespace Invoice {
  /**
   * @export
   * @enum {string}
   */
  export enum InvoiceTypeEnum {
    Unknown = <any>"Unknown",
    FS = <any>"FS",
    XH = <any>"XH",
    TI = <any>"TI",
    R = <any>"R",
    A = <any>"A",
    U = <any>"U",
    H = <any>"H",
    B = <any>"B",
    S = <any>"S",
    I = <any>"I",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum InvoiceSystemEnum {
    B = <any>"B",
    G = <any>"G",
    H = <any>"H",
    K = <any>"K",
    L = <any>"L",
    R = <any>"R",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum OriginSystemEnum {
    U = <any>"U",
    O = <any>"O",
  }
}
/**
 *
 * @export
 * @interface MeteringPointInfo
 */
export interface MeteringPointInfo {
  /**
   *
   * @type {number}
   * @memberof MeteringPointInfo
   */
  meterNumber?: number;
  /**
   *
   * @type {number}
   * @memberof MeteringPointInfo
   */
  serviceIdendifier?: number;
  /**
   *
   * @type {string}
   * @memberof MeteringPointInfo
   */
  meteringPointName?: string;
  /**
   *
   * @type {string}
   * @memberof MeteringPointInfo
   */
  meterPlaceAddress?: string;
  /**
   *
   * @type {string}
   * @memberof MeteringPointInfo
   */
  meterPlacePostalCode?: string;
  /**
   *
   * @type {string}
   * @memberof MeteringPointInfo
   */
  meterPlaceCity?: string;
  /**
   *
   * @type {string}
   * @memberof MeteringPointInfo
   */
  contractStatus?: string;
}
/**
 *
 * @export
 * @interface NestedEchoPostBody
 */
export interface NestedEchoPostBody {
  /**
   *
   * @type {number}
   * @memberof NestedEchoPostBody
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof NestedEchoPostBody
   */
  name?: string;
}
/**
 *
 * @export
 * @interface ORECSIMLoginResponse
 */
export interface ORECSIMLoginResponse {
  /**
   *
   * @type {string}
   * @memberof ORECSIMLoginResponse
   */
  sagaId?: string;
  /**
   *
   * @type {string}
   * @memberof ORECSIMLoginResponse
   */
  callbackCorrelationId?: string;
  /**
   *
   * @type {string}
   * @memberof ORECSIMLoginResponse
   */
  orecSIMLoginResponseType?: ORECSIMLoginResponse.OrecSIMLoginResponseTypeEnum;
  /**
   *
   * @type {string}
   * @memberof ORECSIMLoginResponse
   */
  phoneNumber?: string;
  /**
   *
   * @type {string}
   * @memberof ORECSIMLoginResponse
   */
  personNumber?: string;
  /**
   *
   * @type {string}
   * @memberof ORECSIMLoginResponse
   */
  fullname?: string;
}

/**
 * @export
 * @namespace ORECSIMLoginResponse
 */
export namespace ORECSIMLoginResponse {
  /**
   * @export
   * @enum {string}
   */
  export enum OrecSIMLoginResponseTypeEnum {
    Failure = <any>"Failure",
    Success = <any>"Success",
    Cancelled = <any>"Cancelled",
    Error = <any>"Error",
  }
}
/**
 *
 * @export
 * @interface OceanGetUserInfoExternalResponse
 */
export interface OceanGetUserInfoExternalResponse {
  /**
   *
   * @type {string}
   * @memberof OceanGetUserInfoExternalResponse
   */
  callbackCorrelationId?: string;
  /**
   *
   * @type {OceanUser}
   * @memberof OceanGetUserInfoExternalResponse
   */
  oceanUser?: OceanUser;
}
/**
 *
 * @export
 * @interface OceanUser
 */
export interface OceanUser {
  /**
   *
   * @type {string}
   * @memberof OceanUser
   */
  externalCode?: string;
  /**
   *
   * @type {string}
   * @memberof OceanUser
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof OceanUser
   */
  lastName?: string;
  /**
   *
   * @type {number}
   * @memberof OceanUser
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof OceanUser
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof OceanUser
   */
  phone?: string;
}
/**
 *
 * @export
 * @interface OnEnergyUsageMeteringPointContract
 */
export interface OnEnergyUsageMeteringPointContract {
  /**
   *
   * @type {string}
   * @memberof OnEnergyUsageMeteringPointContract
   */
  meterNumber?: string;
  /**
   *
   * @type {number}
   * @memberof OnEnergyUsageMeteringPointContract
   */
  meteringPointId?: number;
  /**
   *
   * @type {number}
   * @memberof OnEnergyUsageMeteringPointContract
   */
  serviceIdentifier?: number;
  /**
   *
   * @type {string}
   * @memberof OnEnergyUsageMeteringPointContract
   */
  meteringPointName?: string;
  /**
   *
   * @type {string}
   * @memberof OnEnergyUsageMeteringPointContract
   */
  meterPlaceAddress?: string;
  /**
   *
   * @type {number}
   * @memberof OnEnergyUsageMeteringPointContract
   */
  meterPlacePostalCode?: number;
  /**
   *
   * @type {string}
   * @memberof OnEnergyUsageMeteringPointContract
   */
  meterPlaceCity?: string;
  /**
   *
   * @type {boolean}
   * @memberof OnEnergyUsageMeteringPointContract
   */
  isCurrentOwner?: boolean;
  /**
   *
   * @type {Date}
   * @memberof OnEnergyUsageMeteringPointContract
   */
  ownershipStart?: Date;
  /**
   *
   * @type {Date}
   * @memberof OnEnergyUsageMeteringPointContract
   */
  ownershipEnd?: Date;
}
/**
 *
 * @export
 * @interface OnEnergyUsageMeteringPointDeliveryDTO
 */
export interface OnEnergyUsageMeteringPointDeliveryDTO {
  /**
   *
   * @type {string}
   * @memberof OnEnergyUsageMeteringPointDeliveryDTO
   */
  callbackCorrelationId?: string;
  /**
   *
   * @type {string}
   * @memberof OnEnergyUsageMeteringPointDeliveryDTO
   */
  deliveryEndpointURL?: string;
  /**
   *
   * @type {OnEnergyUsageMeteringPointResponse}
   * @memberof OnEnergyUsageMeteringPointDeliveryDTO
   */
  model?: OnEnergyUsageMeteringPointResponse;
}
/**
 *
 * @export
 * @interface OnEnergyUsageMeteringPointResponse
 */
export interface OnEnergyUsageMeteringPointResponse {
  /**
   *
   * @type {string}
   * @memberof OnEnergyUsageMeteringPointResponse
   */
  ssn?: string;
  /**
   *
   * @type {Array<OnEnergyUsageMeteringPointContract>}
   * @memberof OnEnergyUsageMeteringPointResponse
   */
  meteringPointContracts?: Array<OnEnergyUsageMeteringPointContract>;
}
/**
 *
 * @export
 * @interface OnHomechargeExtraProductPurchase
 */
export interface OnHomechargeExtraProductPurchase {
  /**
   *
   * @type {string}
   * @memberof OnHomechargeExtraProductPurchase
   */
  productNumber: string;
  /**
   *
   * @type {number}
   * @memberof OnHomechargeExtraProductPurchase
   */
  unitPrice: number;
  /**
   *
   * @type {number}
   * @memberof OnHomechargeExtraProductPurchase
   */
  quantity: number;
  /**
   *
   * @type {number}
   * @memberof OnHomechargeExtraProductPurchase
   */
  totalPrice: number;
}
/**
 *
 * @export
 * @interface OnPaymentsCustomer
 */
export interface OnPaymentsCustomer {
  /**
   *
   * @type {boolean}
   * @memberof OnPaymentsCustomer
   */
  isError?: boolean;
  /**
   *
   * @type {number}
   * @memberof OnPaymentsCustomer
   */
  errorCode?: number;
  /**
   *
   * @type {string}
   * @memberof OnPaymentsCustomer
   */
  errorMessage?: string;
  /**
   *
   * @type {boolean}
   * @memberof OnPaymentsCustomer
   */
  isActiveCustomerOfON?: boolean;
  /**
   *
   * @type {Array<OnPaymentsPaymentMethod>}
   * @memberof OnPaymentsCustomer
   */
  availablePaymentMethods?: Array<OnPaymentsPaymentMethod>;
}
/**
 *
 * @export
 * @interface OnPaymentsGetCustomerResponse
 */
export interface OnPaymentsGetCustomerResponse {
  /**
   *
   * @type {OnPaymentsCustomer}
   * @memberof OnPaymentsGetCustomerResponse
   */
  customer?: OnPaymentsCustomer;
  /**
   *
   * @type {string}
   * @memberof OnPaymentsGetCustomerResponse
   */
  callbackCorrelationId?: string;
}
/**
 *
 * @export
 * @interface OnPaymentsPaymentMethod
 */
export interface OnPaymentsPaymentMethod {
  /**
   *
   * @type {string}
   * @memberof OnPaymentsPaymentMethod
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof OnPaymentsPaymentMethod
   */
  name?: string;
  /**
   *
   * @type {boolean}
   * @memberof OnPaymentsPaymentMethod
   */
  isExternalCardRegistrationForm?: boolean;
}
/**
 *
 * @export
 * @interface OnPaymentsSetSimplePaymentMethodRequestPayload
 */
export interface OnPaymentsSetSimplePaymentMethodRequestPayload {
  /**
   *
   * @type {string}
   * @memberof OnPaymentsSetSimplePaymentMethodRequestPayload
   */
  formId: string;
  /**
   *
   * @type {string}
   * @memberof OnPaymentsSetSimplePaymentMethodRequestPayload
   */
  paymentMethodChangeType: OnPaymentsSetSimplePaymentMethodRequestPayload.PaymentMethodChangeTypeEnum;
}

/**
 * @export
 * @namespace OnPaymentsSetSimplePaymentMethodRequestPayload
 */
export namespace OnPaymentsSetSimplePaymentMethodRequestPayload {
  /**
   * @export
   * @enum {string}
   */
  export enum PaymentMethodChangeTypeEnum {
    Undefined = <any>"Undefined",
    Heimabanki = <any>"Heimabanki",
    Greislukort = <any>"Greiðslukort",
    Greisluseill = <any>"Greiðsluseðill",
  }
}
/**
 *
 * @export
 * @interface OnboardingSubmittedData
 */
export interface OnboardingSubmittedData {
  /**
   *
   * @type {string}
   * @memberof OnboardingSubmittedData
   */
  sessionId?: string;
  /**
   *
   * @type {string}
   * @memberof OnboardingSubmittedData
   */
  contactPhoneNumber?: string;
  /**
   *
   * @type {string}
   * @memberof OnboardingSubmittedData
   */
  contactEmail?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof OnboardingSubmittedData
   */
  propertyIdsToMoveToON?: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof OnboardingSubmittedData
   */
  allowSalespersonToContactForHomeCharge?: boolean;
}
/**
 *
 * @export
 * @interface OrderApartmentComplexFoundationContact
 */
export interface OrderApartmentComplexFoundationContact {
  /**
   *
   * @type {string}
   * @memberof OrderApartmentComplexFoundationContact
   */
  fullName: string;
  /**
   *
   * @type {string}
   * @memberof OrderApartmentComplexFoundationContact
   */
  phoneNumber: string;
  /**
   *
   * @type {string}
   * @memberof OrderApartmentComplexFoundationContact
   */
  email: string;
}
/**
 *
 * @export
 * @interface OrderApartmentComplexFoundationCustomer
 */
export interface OrderApartmentComplexFoundationCustomer {
  /**
   *
   * @type {string}
   * @memberof OrderApartmentComplexFoundationCustomer
   */
  nationalId: string;
}
/**
 *
 * @export
 * @interface OrderApartmentComplexFoundationLocation
 */
export interface OrderApartmentComplexFoundationLocation {
  /**
   *
   * @type {string}
   * @memberof OrderApartmentComplexFoundationLocation
   */
  street: string;
  /**
   *
   * @type {number}
   * @memberof OrderApartmentComplexFoundationLocation
   */
  postalCode?: number;
  /**
   *
   * @type {string}
   * @memberof OrderApartmentComplexFoundationLocation
   */
  city: string;
}
/**
 *
 * @export
 * @interface OrderApartmentComplexFoundationSubmittedData
 */
export interface OrderApartmentComplexFoundationSubmittedData {
  /**
   *
   * @type {string}
   * @memberof OrderApartmentComplexFoundationSubmittedData
   */
  requestId: string;
  /**
   *
   * @type {Date}
   * @memberof OrderApartmentComplexFoundationSubmittedData
   */
  submissionDate: Date;
  /**
   *
   * @type {string}
   * @memberof OrderApartmentComplexFoundationSubmittedData
   */
  visitationTime: string;
  /**
   *
   * @type {string}
   * @memberof OrderApartmentComplexFoundationSubmittedData
   */
  otherInfo?: string;
  /**
   *
   * @type {OrderApartmentComplexFoundationCustomer}
   * @memberof OrderApartmentComplexFoundationSubmittedData
   */
  customer?: OrderApartmentComplexFoundationCustomer;
  /**
   *
   * @type {OrderApartmentComplexFoundationLocation}
   * @memberof OrderApartmentComplexFoundationSubmittedData
   */
  location?: OrderApartmentComplexFoundationLocation;
  /**
   *
   * @type {OrderApartmentComplexFoundationContact}
   * @memberof OrderApartmentComplexFoundationSubmittedData
   */
  contact?: OrderApartmentComplexFoundationContact;
}
/**
 *
 * @export
 * @interface OrderApartmentContact
 */
export interface OrderApartmentContact {
  /**
   *
   * @type {string}
   * @memberof OrderApartmentContact
   */
  fullName: string;
  /**
   *
   * @type {string}
   * @memberof OrderApartmentContact
   */
  phoneNumber: string;
  /**
   *
   * @type {string}
   * @memberof OrderApartmentContact
   */
  email: string;
}
/**
 *
 * @export
 * @interface OrderApartmentCosts
 */
export interface OrderApartmentCosts {
  /**
   *
   * @type {number}
   * @memberof OrderApartmentCosts
   */
  subscriptionPrice: number;
  /**
   *
   * @type {number}
   * @memberof OrderApartmentCosts
   */
  totalExtraProductsPrice: number;
}
/**
 *
 * @export
 * @interface OrderApartmentCustomer
 */
export interface OrderApartmentCustomer {
  /**
   *
   * @type {string}
   * @memberof OrderApartmentCustomer
   */
  fullName: string;
  /**
   *
   * @type {string}
   * @memberof OrderApartmentCustomer
   */
  nationalId: string;
  /**
   *
   * @type {string}
   * @memberof OrderApartmentCustomer
   */
  phoneNumber: string;
  /**
   *
   * @type {string}
   * @memberof OrderApartmentCustomer
   */
  email: string;
}
/**
 *
 * @export
 * @interface OrderApartmentLocation
 */
export interface OrderApartmentLocation {
  /**
   *
   * @type {string}
   * @memberof OrderApartmentLocation
   */
  street: string;
  /**
   *
   * @type {number}
   * @memberof OrderApartmentLocation
   */
  postalCode?: number;
  /**
   *
   * @type {string}
   * @memberof OrderApartmentLocation
   */
  city: string;
  /**
   *
   * @type {string}
   * @memberof OrderApartmentLocation
   */
  parkingSpotDescription?: string;
  /**
   *
   * @type {number}
   * @memberof OrderApartmentLocation
   */
  dockNumber?: number;
}
/**
 *
 * @export
 * @interface OrderApartmentSubmittedData
 */
export interface OrderApartmentSubmittedData {
  /**
   *
   * @type {string}
   * @memberof OrderApartmentSubmittedData
   */
  requestId: string;
  /**
   *
   * @type {Date}
   * @memberof OrderApartmentSubmittedData
   */
  submissionDate: Date;
  /**
   *
   * @type {boolean}
   * @memberof OrderApartmentSubmittedData
   */
  agreedToTerms: boolean;
  /**
   *
   * @type {boolean}
   * @memberof OrderApartmentSubmittedData
   */
  hasSelectedElectricityOnboarding?: boolean;
  /**
   *
   * @type {ElectronicCredentials}
   * @memberof OrderApartmentSubmittedData
   */
  electronicCredentials?: ElectronicCredentials;
  /**
   *
   * @type {OrderApartmentCustomer}
   * @memberof OrderApartmentSubmittedData
   */
  customer: OrderApartmentCustomer;
  /**
   *
   * @type {OrderApartmentContact}
   * @memberof OrderApartmentSubmittedData
   */
  contact?: OrderApartmentContact;
  /**
   *
   * @type {OrderApartmentLocation}
   * @memberof OrderApartmentSubmittedData
   */
  location: OrderApartmentLocation;
  /**
   *
   * @type {Array<OnHomechargeExtraProductPurchase>}
   * @memberof OrderApartmentSubmittedData
   */
  extraProductPurchases: Array<OnHomechargeExtraProductPurchase>;
  /**
   *
   * @type {OrderApartmentCosts}
   * @memberof OrderApartmentSubmittedData
   */
  costs?: OrderApartmentCosts;
}
/**
 *
 * @export
 * @interface OrderCompanyFoundationContact
 */
export interface OrderCompanyFoundationContact {
  /**
   *
   * @type {string}
   * @memberof OrderCompanyFoundationContact
   */
  fullName: string;
  /**
   *
   * @type {string}
   * @memberof OrderCompanyFoundationContact
   */
  phoneNumber: string;
  /**
   *
   * @type {string}
   * @memberof OrderCompanyFoundationContact
   */
  email: string;
}
/**
 *
 * @export
 * @interface OrderCompanyFoundationCustomer
 */
export interface OrderCompanyFoundationCustomer {
  /**
   *
   * @type {string}
   * @memberof OrderCompanyFoundationCustomer
   */
  nationalId: string;
}
/**
 *
 * @export
 * @interface OrderCompanyFoundationLocation
 */
export interface OrderCompanyFoundationLocation {
  /**
   *
   * @type {string}
   * @memberof OrderCompanyFoundationLocation
   */
  street: string;
  /**
   *
   * @type {number}
   * @memberof OrderCompanyFoundationLocation
   */
  postalCode?: number;
  /**
   *
   * @type {string}
   * @memberof OrderCompanyFoundationLocation
   */
  city: string;
}
/**
 *
 * @export
 * @interface OrderCompanyFoundationSubmittedData
 */
export interface OrderCompanyFoundationSubmittedData {
  /**
   *
   * @type {string}
   * @memberof OrderCompanyFoundationSubmittedData
   */
  requestId: string;
  /**
   *
   * @type {Date}
   * @memberof OrderCompanyFoundationSubmittedData
   */
  submissionDate: Date;
  /**
   *
   * @type {string}
   * @memberof OrderCompanyFoundationSubmittedData
   */
  visitationTime: string;
  /**
   *
   * @type {string}
   * @memberof OrderCompanyFoundationSubmittedData
   */
  otherInfo?: string;
  /**
   *
   * @type {OrderCompanyFoundationCustomer}
   * @memberof OrderCompanyFoundationSubmittedData
   */
  customer: OrderCompanyFoundationCustomer;
  /**
   *
   * @type {OrderCompanyFoundationLocation}
   * @memberof OrderCompanyFoundationSubmittedData
   */
  location?: OrderCompanyFoundationLocation;
  /**
   *
   * @type {OrderCompanyFoundationContact}
   * @memberof OrderCompanyFoundationSubmittedData
   */
  contact?: OrderCompanyFoundationContact;
}
/**
 *
 * @export
 * @interface OrderHouseContact
 */
export interface OrderHouseContact {
  /**
   *
   * @type {string}
   * @memberof OrderHouseContact
   */
  fullName: string;
  /**
   *
   * @type {string}
   * @memberof OrderHouseContact
   */
  phoneNumber: string;
  /**
   *
   * @type {string}
   * @memberof OrderHouseContact
   */
  email: string;
}
/**
 *
 * @export
 * @interface OrderHouseCosts
 */
export interface OrderHouseCosts {
  /**
   *
   * @type {number}
   * @memberof OrderHouseCosts
   */
  subscriptionPrice: number;
  /**
   *
   * @type {number}
   * @memberof OrderHouseCosts
   */
  totalSetupPrice: number;
  /**
   *
   * @type {number}
   * @memberof OrderHouseCosts
   */
  totalExtraProductsPrice: number;
  /**
   *
   * @type {number}
   * @memberof OrderHouseCosts
   */
  totalPrice: number;
  /**
   *
   * @type {boolean}
   * @memberof OrderHouseCosts
   */
  setupRequiresPriceQuote: boolean;
  /**
   *
   * @type {boolean}
   * @memberof OrderHouseCosts
   */
  paymentDistributionRequested: boolean;
  /**
   *
   * @type {number}
   * @memberof OrderHouseCosts
   */
  paymentDistributedOverNumberOfMonths?: number;
  /**
   *
   * @type {number}
   * @memberof OrderHouseCosts
   */
  paymentDistributionPricePerMonth?: number;
}
/**
 *
 * @export
 * @interface OrderHouseCustomer
 */
export interface OrderHouseCustomer {
  /**
   *
   * @type {string}
   * @memberof OrderHouseCustomer
   */
  fullName: string;
  /**
   *
   * @type {string}
   * @memberof OrderHouseCustomer
   */
  nationalId: string;
  /**
   *
   * @type {string}
   * @memberof OrderHouseCustomer
   */
  phoneNumber: string;
  /**
   *
   * @type {string}
   * @memberof OrderHouseCustomer
   */
  email: string;
}
/**
 *
 * @export
 * @interface OrderHouseLocation
 */
export interface OrderHouseLocation {
  /**
   *
   * @type {string}
   * @memberof OrderHouseLocation
   */
  street: string;
  /**
   *
   * @type {number}
   * @memberof OrderHouseLocation
   */
  postalCode?: number;
  /**
   *
   * @type {string}
   * @memberof OrderHouseLocation
   */
  city: string;
}
/**
 *
 * @export
 * @interface OrderHouseSetupQuestionAnswer
 */
export interface OrderHouseSetupQuestionAnswer {
  /**
   *
   * @type {string}
   * @memberof OrderHouseSetupQuestionAnswer
   */
  questionId: string;
  /**
   *
   * @type {string}
   * @memberof OrderHouseSetupQuestionAnswer
   */
  answerId: string;
}
/**
 *
 * @export
 * @interface OrderHouseSubmittedData
 */
export interface OrderHouseSubmittedData {
  /**
   *
   * @type {string}
   * @memberof OrderHouseSubmittedData
   */
  requestId: string;
  /**
   *
   * @type {Date}
   * @memberof OrderHouseSubmittedData
   */
  submissionDate: Date;
  /**
   *
   * @type {boolean}
   * @memberof OrderHouseSubmittedData
   */
  agreedToTerms: boolean;
  /**
   *
   * @type {boolean}
   * @memberof OrderHouseSubmittedData
   */
  hasSelectedElectricityOnboarding?: boolean;
  /**
   *
   * @type {ElectronicCredentials}
   * @memberof OrderHouseSubmittedData
   */
  electronicCredentials?: ElectronicCredentials;
  /**
   *
   * @type {OrderHouseCustomer}
   * @memberof OrderHouseSubmittedData
   */
  customer: OrderHouseCustomer;
  /**
   *
   * @type {OrderHouseContact}
   * @memberof OrderHouseSubmittedData
   */
  contact?: OrderHouseContact;
  /**
   *
   * @type {OrderHouseLocation}
   * @memberof OrderHouseSubmittedData
   */
  location: OrderHouseLocation;
  /**
   *
   * @type {string}
   * @memberof OrderHouseSubmittedData
   */
  setupDescription?: string;
  /**
   *
   * @type {Array<OrderHouseSetupQuestionAnswer>}
   * @memberof OrderHouseSubmittedData
   */
  setupQuestionAnswers: Array<OrderHouseSetupQuestionAnswer>;
  /**
   *
   * @type {Array<OnHomechargeExtraProductPurchase>}
   * @memberof OrderHouseSubmittedData
   */
  extraProductPurchases: Array<OnHomechargeExtraProductPurchase>;
  /**
   *
   * @type {OrderHouseCosts}
   * @memberof OrderHouseSubmittedData
   */
  costs: OrderHouseCosts;
}
/**
 *
 * @export
 * @interface ProblemDetails
 */
export interface ProblemDetails {
  [key: string]: any;
}
/**
 *
 * @export
 * @interface SetUserOrecPasswordResponse
 */
export interface SetUserOrecPasswordResponse {
  /**
   *
   * @type {string}
   * @memberof SetUserOrecPasswordResponse
   */
  callbackCorrelationId?: string;
  /**
   *
   * @type {boolean}
   * @memberof SetUserOrecPasswordResponse
   */
  passwordUpdatedSuccessfully?: boolean;
  /**
   *
   * @type {string}
   * @memberof SetUserOrecPasswordResponse
   */
  additionalInformation?: string;
}
/**
 *
 * @export
 * @interface StandardsCompatibility
 */
export interface StandardsCompatibility {
  /**
   *
   * @type {boolean}
   * @memberof StandardsCompatibility
   */
  dcCharging?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof StandardsCompatibility
   */
  ieC61851?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof StandardsCompatibility
   */
  ieC15118AC?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof StandardsCompatibility
   */
  ieC15118DC?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof StandardsCompatibility
   */
  acCharging?: boolean;
}
/**
 *
 * @export
 * @interface SubmitFile
 */
export interface SubmitFile {
  /**
   *
   * @type {string}
   * @memberof SubmitFile
   */
  fileId?: string;
  /**
   *
   * @type {string}
   * @memberof SubmitFile
   */
  idOfUploader?: string;
  /**
   *
   * @type {string}
   * @memberof SubmitFile
   */
  idOfSubject?: string;
}
/**
 *
 * @export
 * @interface Transaction
 */
export interface Transaction {
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  transactionNumber?: string;
  /**
   *
   * @type {Date}
   * @memberof Transaction
   */
  transactionDate?: Date;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  transactionText?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  serviceType?: Transaction.ServiceTypeEnum;
  /**
   *
   * @type {Date}
   * @memberof Transaction
   */
  dueDate?: Date;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  explanation?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  accountNumber?: string;
  /**
   *
   * @type {number}
   * @memberof Transaction
   */
  transactionAmount?: number;
  /**
   *
   * @type {number}
   * @memberof Transaction
   */
  remainingAmount?: number;
  /**
   *
   * @type {number}
   * @memberof Transaction
   */
  balance?: number;
}

/**
 * @export
 * @namespace Transaction
 */
export namespace Transaction {
  /**
   * @export
   * @enum {string}
   */
  export enum ServiceTypeEnum {
    Unknown = <any>"Unknown",
    ChargingReceipt = <any>"ChargingReceipt",
    ChargingSubscription = <any>"ChargingSubscription",
    EnergyUsage = <any>"EnergyUsage",
    Item = <any>"Item",
    ProductPurchase = <any>"ProductPurchase",
  }
}
/**
 *
 * @export
 * @interface UserData
 */
export interface UserData {
  /**
   *
   * @type {number}
   * @memberof UserData
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof UserData
   */
  username?: string;
  /**
   *
   * @type {number}
   * @memberof UserData
   */
  userPayerId?: number;
  /**
   *
   * @type {number}
   * @memberof UserData
   */
  paymentTypeId?: number;
  /**
   *
   * @type {number}
   * @memberof UserData
   */
  paymentProviderId?: number;
  /**
   *
   * @type {string}
   * @memberof UserData
   */
  userPayerName?: string;
  /**
   *
   * @type {string}
   * @memberof UserData
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof UserData
   */
  gsmNumber?: string;
  /**
   *
   * @type {string}
   * @memberof UserData
   */
  uiCultureTitle?: string;
  /**
   *
   * @type {UserDataIDTitle}
   * @memberof UserData
   */
  uiCulture?: UserDataIDTitle;
  /**
   *
   * @type {number}
   * @memberof UserData
   */
  defaultTimeZone?: number;
  /**
   *
   * @type {number}
   * @memberof UserData
   */
  registrationFormTypeId?: number;
  /**
   *
   * @type {string}
   * @memberof UserData
   */
  currencyCode?: string;
  /**
   *
   * @type {boolean}
   * @memberof UserData
   */
  blocked?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof UserData
   */
  hasFleetAccess?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof UserData
   */
  allowAddingPaymentCards?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof UserData
   */
  allowMerchantInitiatedPayment?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof UserData
   */
  displayPaymentCards?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof UserData
   */
  skipPreauthorization?: boolean;
  /**
   *
   * @type {string}
   * @memberof UserData
   */
  externalCode?: string;
  /**
   *
   * @type {boolean}
   * @memberof UserData
   */
  federatedIdentity?: boolean;
}
/**
 *
 * @export
 * @interface UserDataIDTitle
 */
export interface UserDataIDTitle {
  /**
   *
   * @type {string}
   * @memberof UserDataIDTitle
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof UserDataIDTitle
   */
  title?: string;
}
/**
 *
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  personNumber?: string;
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  domainUsername?: string;
  /**
   *
   * @type {boolean}
   * @memberof UserInfo
   */
  isDomainUser?: boolean;
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  phone?: string;
}
/**
 *
 * @export
 * @interface Vehicle
 */
export interface Vehicle {
  /**
   *
   * @type {number}
   * @memberof Vehicle
   */
  id?: number;
  /**
   *
   * @type {IDTitle}
   * @memberof Vehicle
   */
  vehicleBrand?: IDTitle;
  /**
   *
   * @type {IDTitle}
   * @memberof Vehicle
   */
  vehicleModel?: IDTitle;
  /**
   *
   * @type {boolean}
   * @memberof Vehicle
   */
  isDefaultVehicle?: boolean;
}
/**
 *
 * @export
 * @interface Version
 */
export interface Version {
  /**
   *
   * @type {number}
   * @memberof Version
   */
  id?: number;
  /**
   *
   * @type {IDTitle}
   * @memberof Version
   */
  vehicleBrand?: IDTitle;
  /**
   *
   * @type {IDTitle}
   * @memberof Version
   */
  vehicleModel?: IDTitle;
  /**
   *
   * @type {number}
   * @memberof Version
   */
  maximumRange?: number;
  /**
   *
   * @type {number}
   * @memberof Version
   */
  batteryCapacity?: number;
  /**
   *
   * @type {ACconnectorType}
   * @memberof Version
   */
  aCconnectorType?: ACconnectorType;
  /**
   *
   * @type {number}
   * @memberof Version
   */
  minChargingCurrentAC?: number;
  /**
   *
   * @type {number}
   * @memberof Version
   */
  maxChargingCurrentAC?: number;
  /**
   *
   * @type {number}
   * @memberof Version
   */
  numberOfPhases?: number;
  /**
   *
   * @type {DCconnectorType}
   * @memberof Version
   */
  dCconnectorType?: DCconnectorType;
  /**
   *
   * @type {number}
   * @memberof Version
   */
  minChargingPowerDC?: number;
  /**
   *
   * @type {number}
   * @memberof Version
   */
  maxChargingPowerDC?: number;
  /**
   *
   * @type {number}
   * @memberof Version
   */
  voltageDCCharging?: number;
  /**
   *
   * @type {StandardsCompatibility}
   * @memberof Version
   */
  standardsCompatibility?: StandardsCompatibility;
}
/**
 * AuthApi - fetch parameter creator
 * @export
 */
export const AuthApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {AuthAppLoginResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authDeliverAppLoginResponsePost(
      body?: AuthAppLoginResponse,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/auth/deliver-app-login-response`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AuthAppLoginResponse" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {AuthCRMTokenLoginResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authDeliverCrmTokenLoginResponsePost(
      body?: AuthCRMTokenLoginResponse,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/auth/deliver-crm-token-login-response`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AuthCRMTokenLoginResponse" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {AuthPhoneNumberSIMLoginResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authDeliverLoginResponsePost(
      body?: AuthPhoneNumberSIMLoginResponse,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/auth/deliver-login-response`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AuthPhoneNumberSIMLoginResponse" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {AuthAppVerificationCodeResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authDeliverVerificationCodeResponsePost(
      body?: AuthAppVerificationCodeResponse,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/auth/deliver-verification-code-response`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AuthAppVerificationCodeResponse" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {AuthAppLoginResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authDeliverAppLoginResponsePost(
      body?: AuthAppLoginResponse,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AuthApiFetchParamCreator(
        configuration
      ).authDeliverAppLoginResponsePost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {AuthCRMTokenLoginResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authDeliverCrmTokenLoginResponsePost(
      body?: AuthCRMTokenLoginResponse,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AuthApiFetchParamCreator(
        configuration
      ).authDeliverCrmTokenLoginResponsePost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {AuthPhoneNumberSIMLoginResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authDeliverLoginResponsePost(
      body?: AuthPhoneNumberSIMLoginResponse,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AuthApiFetchParamCreator(
        configuration
      ).authDeliverLoginResponsePost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {AuthAppVerificationCodeResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authDeliverVerificationCodeResponsePost(
      body?: AuthAppVerificationCodeResponse,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AuthApiFetchParamCreator(
        configuration
      ).authDeliverVerificationCodeResponsePost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {AuthAppLoginResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authDeliverAppLoginResponsePost(
      body?: AuthAppLoginResponse,
      options?: any
    ) {
      return AuthApiFp(configuration).authDeliverAppLoginResponsePost(
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {AuthCRMTokenLoginResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authDeliverCrmTokenLoginResponsePost(
      body?: AuthCRMTokenLoginResponse,
      options?: any
    ) {
      return AuthApiFp(configuration).authDeliverCrmTokenLoginResponsePost(
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {AuthPhoneNumberSIMLoginResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authDeliverLoginResponsePost(
      body?: AuthPhoneNumberSIMLoginResponse,
      options?: any
    ) {
      return AuthApiFp(configuration).authDeliverLoginResponsePost(
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {AuthAppVerificationCodeResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authDeliverVerificationCodeResponsePost(
      body?: AuthAppVerificationCodeResponse,
      options?: any
    ) {
      return AuthApiFp(configuration).authDeliverVerificationCodeResponsePost(
        body,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   *
   * @param {AuthAppLoginResponse} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authDeliverAppLoginResponsePost(
    body?: AuthAppLoginResponse,
    options?: any
  ) {
    return AuthApiFp(this.configuration).authDeliverAppLoginResponsePost(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {AuthCRMTokenLoginResponse} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authDeliverCrmTokenLoginResponsePost(
    body?: AuthCRMTokenLoginResponse,
    options?: any
  ) {
    return AuthApiFp(this.configuration).authDeliverCrmTokenLoginResponsePost(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {AuthPhoneNumberSIMLoginResponse} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authDeliverLoginResponsePost(
    body?: AuthPhoneNumberSIMLoginResponse,
    options?: any
  ) {
    return AuthApiFp(this.configuration).authDeliverLoginResponsePost(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {AuthAppVerificationCodeResponse} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authDeliverVerificationCodeResponsePost(
    body?: AuthAppVerificationCodeResponse,
    options?: any
  ) {
    return AuthApiFp(
      this.configuration
    ).authDeliverVerificationCodeResponsePost(body, options)(
      this.fetch,
      this.basePath
    );
  }
}
/**
 * DocumentApi - fetch parameter creator
 * @export
 */
export const DocumentApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {string} [idOfSubject]
     * @param {string} [fileId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    documentsDeleteFilePermanentlyPost(
      idOfSubject?: string,
      fileId?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/documents/delete-file-permanently`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new URLSearchParams();

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      if (idOfSubject !== undefined) {
        localVarFormParams.set("IdOfSubject", idOfSubject as any);
      }

      if (fileId !== undefined) {
        localVarFormParams.set("FileId", fileId as any);
      }

      localVarHeaderParameter["Content-Type"] =
        "application/x-www-form-urlencoded";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      localVarRequestOptions.body = localVarFormParams.toString();

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [idOfSubject]
     * @param {string} [fileId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    documentsDeleteFilePost(
      idOfSubject?: string,
      fileId?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/documents/delete-file`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new URLSearchParams();

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      if (idOfSubject !== undefined) {
        localVarFormParams.set("IdOfSubject", idOfSubject as any);
      }

      if (fileId !== undefined) {
        localVarFormParams.set("FileId", fileId as any);
      }

      localVarHeaderParameter["Content-Type"] =
        "application/x-www-form-urlencoded";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      localVarRequestOptions.body = localVarFormParams.toString();

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [idOfSubject]
     * @param {string} [fileId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    documentsGetFileDownloadGet(
      idOfSubject?: string,
      fileId?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/documents/get-file-download`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      if (idOfSubject !== undefined) {
        localVarQueryParameter["idOfSubject"] = idOfSubject;
      }

      if (fileId !== undefined) {
        localVarQueryParameter["FileId"] = fileId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [idOfSubject]
     * @param {string} [fileId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    documentsGetFileInformationGet(
      idOfSubject?: string,
      fileId?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/documents/get-file-information`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      if (idOfSubject !== undefined) {
        localVarQueryParameter["idOfSubject"] = idOfSubject;
      }

      if (fileId !== undefined) {
        localVarQueryParameter["FileId"] = fileId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [idOfSubject]
     * @param {Array<string>} [fileIds]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    documentsGetMultipleFilesDownloadGet(
      idOfSubject?: string,
      fileIds?: Array<string>,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/documents/get-multiple-files-download`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      if (idOfSubject !== undefined) {
        localVarQueryParameter["IdOfSubject"] = idOfSubject;
      }

      if (fileIds) {
        localVarQueryParameter["FileIds"] = fileIds;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {Array<SubmitFile>} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    documentsSubmitFilesPost(
      body?: Array<SubmitFile>,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/documents/submit-files`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"Array&lt;SubmitFile&gt;" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {Blob} [file]
     * @param {string} [idOfSubject]
     * @param {string} [company]
     * @param {string} [system]
     * @param {Date} [expiryDateOfFile]
     * @param {boolean} [shouldBeDeletedAfterExpiry]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    documentsUploadFilePost(
      file?: Blob,
      idOfSubject?: string,
      company?: string,
      system?: string,
      expiryDateOfFile?: Date,
      shouldBeDeletedAfterExpiry?: boolean,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/documents/upload-file`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new URLSearchParams();

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      if (file !== undefined) {
        localVarFormParams.set("File", file as any);
      }

      if (idOfSubject !== undefined) {
        localVarFormParams.set("IdOfSubject", idOfSubject as any);
      }

      if (company !== undefined) {
        localVarFormParams.set("Company", company as any);
      }

      if (system !== undefined) {
        localVarFormParams.set("System", system as any);
      }

      if (expiryDateOfFile !== undefined) {
        localVarFormParams.set("ExpiryDateOfFile", expiryDateOfFile as any);
      }

      if (shouldBeDeletedAfterExpiry !== undefined) {
        localVarFormParams.set(
          "ShouldBeDeletedAfterExpiry",
          shouldBeDeletedAfterExpiry as any
        );
      }

      localVarHeaderParameter["Content-Type"] =
        "application/x-www-form-urlencoded";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      localVarRequestOptions.body = localVarFormParams.toString();

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DocumentApi - functional programming interface
 * @export
 */
export const DocumentApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} [idOfSubject]
     * @param {string} [fileId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    documentsDeleteFilePermanentlyPost(
      idOfSubject?: string,
      fileId?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DocumentApiFetchParamCreator(
        configuration
      ).documentsDeleteFilePermanentlyPost(idOfSubject, fileId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} [idOfSubject]
     * @param {string} [fileId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    documentsDeleteFilePost(
      idOfSubject?: string,
      fileId?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DocumentApiFetchParamCreator(
        configuration
      ).documentsDeleteFilePost(idOfSubject, fileId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} [idOfSubject]
     * @param {string} [fileId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    documentsGetFileDownloadGet(
      idOfSubject?: string,
      fileId?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DocumentApiFetchParamCreator(
        configuration
      ).documentsGetFileDownloadGet(idOfSubject, fileId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} [idOfSubject]
     * @param {string} [fileId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    documentsGetFileInformationGet(
      idOfSubject?: string,
      fileId?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DocumentApiFetchParamCreator(
        configuration
      ).documentsGetFileInformationGet(idOfSubject, fileId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} [idOfSubject]
     * @param {Array<string>} [fileIds]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    documentsGetMultipleFilesDownloadGet(
      idOfSubject?: string,
      fileIds?: Array<string>,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DocumentApiFetchParamCreator(
        configuration
      ).documentsGetMultipleFilesDownloadGet(idOfSubject, fileIds, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {Array<SubmitFile>} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    documentsSubmitFilesPost(
      body?: Array<SubmitFile>,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DocumentApiFetchParamCreator(
        configuration
      ).documentsSubmitFilesPost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {Blob} [file]
     * @param {string} [idOfSubject]
     * @param {string} [company]
     * @param {string} [system]
     * @param {Date} [expiryDateOfFile]
     * @param {boolean} [shouldBeDeletedAfterExpiry]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    documentsUploadFilePost(
      file?: Blob,
      idOfSubject?: string,
      company?: string,
      system?: string,
      expiryDateOfFile?: Date,
      shouldBeDeletedAfterExpiry?: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DocumentApiFetchParamCreator(
        configuration
      ).documentsUploadFilePost(
        file,
        idOfSubject,
        company,
        system,
        expiryDateOfFile,
        shouldBeDeletedAfterExpiry,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * DocumentApi - factory interface
 * @export
 */
export const DocumentApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {string} [idOfSubject]
     * @param {string} [fileId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    documentsDeleteFilePermanentlyPost(
      idOfSubject?: string,
      fileId?: string,
      options?: any
    ) {
      return DocumentApiFp(configuration).documentsDeleteFilePermanentlyPost(
        idOfSubject,
        fileId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {string} [idOfSubject]
     * @param {string} [fileId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    documentsDeleteFilePost(
      idOfSubject?: string,
      fileId?: string,
      options?: any
    ) {
      return DocumentApiFp(configuration).documentsDeleteFilePost(
        idOfSubject,
        fileId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {string} [idOfSubject]
     * @param {string} [fileId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    documentsGetFileDownloadGet(
      idOfSubject?: string,
      fileId?: string,
      options?: any
    ) {
      return DocumentApiFp(configuration).documentsGetFileDownloadGet(
        idOfSubject,
        fileId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {string} [idOfSubject]
     * @param {string} [fileId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    documentsGetFileInformationGet(
      idOfSubject?: string,
      fileId?: string,
      options?: any
    ) {
      return DocumentApiFp(configuration).documentsGetFileInformationGet(
        idOfSubject,
        fileId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {string} [idOfSubject]
     * @param {Array<string>} [fileIds]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    documentsGetMultipleFilesDownloadGet(
      idOfSubject?: string,
      fileIds?: Array<string>,
      options?: any
    ) {
      return DocumentApiFp(configuration).documentsGetMultipleFilesDownloadGet(
        idOfSubject,
        fileIds,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {Array<SubmitFile>} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    documentsSubmitFilesPost(body?: Array<SubmitFile>, options?: any) {
      return DocumentApiFp(configuration).documentsSubmitFilesPost(
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {Blob} [file]
     * @param {string} [idOfSubject]
     * @param {string} [company]
     * @param {string} [system]
     * @param {Date} [expiryDateOfFile]
     * @param {boolean} [shouldBeDeletedAfterExpiry]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    documentsUploadFilePost(
      file?: Blob,
      idOfSubject?: string,
      company?: string,
      system?: string,
      expiryDateOfFile?: Date,
      shouldBeDeletedAfterExpiry?: boolean,
      options?: any
    ) {
      return DocumentApiFp(configuration).documentsUploadFilePost(
        file,
        idOfSubject,
        company,
        system,
        expiryDateOfFile,
        shouldBeDeletedAfterExpiry,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * DocumentApi - object-oriented interface
 * @export
 * @class DocumentApi
 * @extends {BaseAPI}
 */
export class DocumentApi extends BaseAPI {
  /**
   *
   * @param {string} [idOfSubject]
   * @param {string} [fileId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentApi
   */
  public documentsDeleteFilePermanentlyPost(
    idOfSubject?: string,
    fileId?: string,
    options?: any
  ) {
    return DocumentApiFp(this.configuration).documentsDeleteFilePermanentlyPost(
      idOfSubject,
      fileId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {string} [idOfSubject]
   * @param {string} [fileId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentApi
   */
  public documentsDeleteFilePost(
    idOfSubject?: string,
    fileId?: string,
    options?: any
  ) {
    return DocumentApiFp(this.configuration).documentsDeleteFilePost(
      idOfSubject,
      fileId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {string} [idOfSubject]
   * @param {string} [fileId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentApi
   */
  public documentsGetFileDownloadGet(
    idOfSubject?: string,
    fileId?: string,
    options?: any
  ) {
    return DocumentApiFp(this.configuration).documentsGetFileDownloadGet(
      idOfSubject,
      fileId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {string} [idOfSubject]
   * @param {string} [fileId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentApi
   */
  public documentsGetFileInformationGet(
    idOfSubject?: string,
    fileId?: string,
    options?: any
  ) {
    return DocumentApiFp(this.configuration).documentsGetFileInformationGet(
      idOfSubject,
      fileId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {string} [idOfSubject]
   * @param {Array<string>} [fileIds]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentApi
   */
  public documentsGetMultipleFilesDownloadGet(
    idOfSubject?: string,
    fileIds?: Array<string>,
    options?: any
  ) {
    return DocumentApiFp(
      this.configuration
    ).documentsGetMultipleFilesDownloadGet(
      idOfSubject,
      fileIds,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {Array<SubmitFile>} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentApi
   */
  public documentsSubmitFilesPost(body?: Array<SubmitFile>, options?: any) {
    return DocumentApiFp(this.configuration).documentsSubmitFilesPost(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {Blob} [file]
   * @param {string} [idOfSubject]
   * @param {string} [company]
   * @param {string} [system]
   * @param {Date} [expiryDateOfFile]
   * @param {boolean} [shouldBeDeletedAfterExpiry]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentApi
   */
  public documentsUploadFilePost(
    file?: Blob,
    idOfSubject?: string,
    company?: string,
    system?: string,
    expiryDateOfFile?: Date,
    shouldBeDeletedAfterExpiry?: boolean,
    options?: any
  ) {
    return DocumentApiFp(this.configuration).documentsUploadFilePost(
      file,
      idOfSubject,
      company,
      system,
      expiryDateOfFile,
      shouldBeDeletedAfterExpiry,
      options
    )(this.fetch, this.basePath);
  }
}
/**
 * ExampleApi - fetch parameter creator
 * @export
 */
export const ExampleApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {EchoPostBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exampleEchoPost(body?: EchoPostBody, options: any = {}): FetchArgs {
      const localVarPath = `/example/echo`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"EchoPostBody" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exampleHelloGet(options: any = {}): FetchArgs {
      const localVarPath = `/example/hello`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exampleWhoAmIGet(options: any = {}): FetchArgs {
      const localVarPath = `/example/who-am-i`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ExampleApi - functional programming interface
 * @export
 */
export const ExampleApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {EchoPostBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exampleEchoPost(
      body?: EchoPostBody,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<EchoPostBody> {
      const localVarFetchArgs = ExampleApiFetchParamCreator(
        configuration
      ).exampleEchoPost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exampleHelloGet(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs =
        ExampleApiFetchParamCreator(configuration).exampleHelloGet(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exampleWhoAmIGet(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UserInfo> {
      const localVarFetchArgs =
        ExampleApiFetchParamCreator(configuration).exampleWhoAmIGet(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * ExampleApi - factory interface
 * @export
 */
export const ExampleApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {EchoPostBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exampleEchoPost(body?: EchoPostBody, options?: any) {
      return ExampleApiFp(configuration).exampleEchoPost(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exampleHelloGet(options?: any) {
      return ExampleApiFp(configuration).exampleHelloGet(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exampleWhoAmIGet(options?: any) {
      return ExampleApiFp(configuration).exampleWhoAmIGet(options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * ExampleApi - object-oriented interface
 * @export
 * @class ExampleApi
 * @extends {BaseAPI}
 */
export class ExampleApi extends BaseAPI {
  /**
   *
   * @param {EchoPostBody} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExampleApi
   */
  public exampleEchoPost(body?: EchoPostBody, options?: any) {
    return ExampleApiFp(this.configuration).exampleEchoPost(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExampleApi
   */
  public exampleHelloGet(options?: any) {
    return ExampleApiFp(this.configuration).exampleHelloGet(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExampleApi
   */
  public exampleWhoAmIGet(options?: any) {
    return ExampleApiFp(this.configuration).exampleWhoAmIGet(options)(
      this.fetch,
      this.basePath
    );
  }
}
/**
 * OceanApi - fetch parameter creator
 * @export
 */
export const OceanApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {OceanGetUserInfoExternalResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oceanDeliverGetUserInfoExternalResponsePost(
      body?: OceanGetUserInfoExternalResponse,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/ocean/deliver-get-user-info-external-response`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"OceanGetUserInfoExternalResponse" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {SetUserOrecPasswordResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oceanDeliverSetUserPasswordInOceanResponsePost(
      body?: SetUserOrecPasswordResponse,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/ocean/deliver-set-user-password-in-ocean-response`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"SetUserOrecPasswordResponse" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OceanApi - functional programming interface
 * @export
 */
export const OceanApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {OceanGetUserInfoExternalResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oceanDeliverGetUserInfoExternalResponsePost(
      body?: OceanGetUserInfoExternalResponse,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = OceanApiFetchParamCreator(
        configuration
      ).oceanDeliverGetUserInfoExternalResponsePost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {SetUserOrecPasswordResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oceanDeliverSetUserPasswordInOceanResponsePost(
      body?: SetUserOrecPasswordResponse,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = OceanApiFetchParamCreator(
        configuration
      ).oceanDeliverSetUserPasswordInOceanResponsePost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * OceanApi - factory interface
 * @export
 */
export const OceanApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {OceanGetUserInfoExternalResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oceanDeliverGetUserInfoExternalResponsePost(
      body?: OceanGetUserInfoExternalResponse,
      options?: any
    ) {
      return OceanApiFp(
        configuration
      ).oceanDeliverGetUserInfoExternalResponsePost(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {SetUserOrecPasswordResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oceanDeliverSetUserPasswordInOceanResponsePost(
      body?: SetUserOrecPasswordResponse,
      options?: any
    ) {
      return OceanApiFp(
        configuration
      ).oceanDeliverSetUserPasswordInOceanResponsePost(body, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * OceanApi - object-oriented interface
 * @export
 * @class OceanApi
 * @extends {BaseAPI}
 */
export class OceanApi extends BaseAPI {
  /**
   *
   * @param {OceanGetUserInfoExternalResponse} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OceanApi
   */
  public oceanDeliverGetUserInfoExternalResponsePost(
    body?: OceanGetUserInfoExternalResponse,
    options?: any
  ) {
    return OceanApiFp(
      this.configuration
    ).oceanDeliverGetUserInfoExternalResponsePost(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {SetUserOrecPasswordResponse} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OceanApi
   */
  public oceanDeliverSetUserPasswordInOceanResponsePost(
    body?: SetUserOrecPasswordResponse,
    options?: any
  ) {
    return OceanApiFp(
      this.configuration
    ).oceanDeliverSetUserPasswordInOceanResponsePost(body, options)(
      this.fetch,
      this.basePath
    );
  }
}
/**
 * OnClaimsApi - fetch parameter creator
 * @export
 */
export const OnClaimsApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {BusClaimDocumentResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onClaimsDeliverClaimDocumentResponsePost(
      body?: BusClaimDocumentResponse,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/on-claims/deliver-claim-document-response`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"BusClaimDocumentResponse" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {BusClaimsResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onClaimsDeliverClaimsResponsePost(
      body?: BusClaimsResponse,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/on-claims/deliver-claims-response`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"BusClaimsResponse" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {BusCollectionLetterDocumentResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onClaimsDeliverCollectionLetterDocumentResponsePost(
      body?: BusCollectionLetterDocumentResponse,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/on-claims/deliver-collection-letter-document-response`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"BusCollectionLetterDocumentResponse" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OnClaimsApi - functional programming interface
 * @export
 */
export const OnClaimsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {BusClaimDocumentResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onClaimsDeliverClaimDocumentResponsePost(
      body?: BusClaimDocumentResponse,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = OnClaimsApiFetchParamCreator(
        configuration
      ).onClaimsDeliverClaimDocumentResponsePost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {BusClaimsResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onClaimsDeliverClaimsResponsePost(
      body?: BusClaimsResponse,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = OnClaimsApiFetchParamCreator(
        configuration
      ).onClaimsDeliverClaimsResponsePost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {BusCollectionLetterDocumentResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onClaimsDeliverCollectionLetterDocumentResponsePost(
      body?: BusCollectionLetterDocumentResponse,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = OnClaimsApiFetchParamCreator(
        configuration
      ).onClaimsDeliverCollectionLetterDocumentResponsePost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * OnClaimsApi - factory interface
 * @export
 */
export const OnClaimsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {BusClaimDocumentResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onClaimsDeliverClaimDocumentResponsePost(
      body?: BusClaimDocumentResponse,
      options?: any
    ) {
      return OnClaimsApiFp(
        configuration
      ).onClaimsDeliverClaimDocumentResponsePost(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {BusClaimsResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onClaimsDeliverClaimsResponsePost(body?: BusClaimsResponse, options?: any) {
      return OnClaimsApiFp(configuration).onClaimsDeliverClaimsResponsePost(
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {BusCollectionLetterDocumentResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onClaimsDeliverCollectionLetterDocumentResponsePost(
      body?: BusCollectionLetterDocumentResponse,
      options?: any
    ) {
      return OnClaimsApiFp(
        configuration
      ).onClaimsDeliverCollectionLetterDocumentResponsePost(body, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * OnClaimsApi - object-oriented interface
 * @export
 * @class OnClaimsApi
 * @extends {BaseAPI}
 */
export class OnClaimsApi extends BaseAPI {
  /**
   *
   * @param {BusClaimDocumentResponse} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OnClaimsApi
   */
  public onClaimsDeliverClaimDocumentResponsePost(
    body?: BusClaimDocumentResponse,
    options?: any
  ) {
    return OnClaimsApiFp(
      this.configuration
    ).onClaimsDeliverClaimDocumentResponsePost(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {BusClaimsResponse} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OnClaimsApi
   */
  public onClaimsDeliverClaimsResponsePost(
    body?: BusClaimsResponse,
    options?: any
  ) {
    return OnClaimsApiFp(this.configuration).onClaimsDeliverClaimsResponsePost(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {BusCollectionLetterDocumentResponse} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OnClaimsApi
   */
  public onClaimsDeliverCollectionLetterDocumentResponsePost(
    body?: BusCollectionLetterDocumentResponse,
    options?: any
  ) {
    return OnClaimsApiFp(
      this.configuration
    ).onClaimsDeliverCollectionLetterDocumentResponsePost(body, options)(
      this.fetch,
      this.basePath
    );
  }
}
/**
 * OnCustomerStatementApi - fetch parameter creator
 * @export
 */
export const OnCustomerStatementApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {BusCustomerStatementResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onCustomerStatementDeliverCustomerStatementResponsePost(
      body?: BusCustomerStatementResponse,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/on-customer-statement/deliver-customer-statement-response`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"BusCustomerStatementResponse" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OnCustomerStatementApi - functional programming interface
 * @export
 */
export const OnCustomerStatementApiFp = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {BusCustomerStatementResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onCustomerStatementDeliverCustomerStatementResponsePost(
      body?: BusCustomerStatementResponse,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = OnCustomerStatementApiFetchParamCreator(
        configuration
      ).onCustomerStatementDeliverCustomerStatementResponsePost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * OnCustomerStatementApi - factory interface
 * @export
 */
export const OnCustomerStatementApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {BusCustomerStatementResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onCustomerStatementDeliverCustomerStatementResponsePost(
      body?: BusCustomerStatementResponse,
      options?: any
    ) {
      return OnCustomerStatementApiFp(
        configuration
      ).onCustomerStatementDeliverCustomerStatementResponsePost(body, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * OnCustomerStatementApi - object-oriented interface
 * @export
 * @class OnCustomerStatementApi
 * @extends {BaseAPI}
 */
export class OnCustomerStatementApi extends BaseAPI {
  /**
   *
   * @param {BusCustomerStatementResponse} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OnCustomerStatementApi
   */
  public onCustomerStatementDeliverCustomerStatementResponsePost(
    body?: BusCustomerStatementResponse,
    options?: any
  ) {
    return OnCustomerStatementApiFp(
      this.configuration
    ).onCustomerStatementDeliverCustomerStatementResponsePost(body, options)(
      this.fetch,
      this.basePath
    );
  }
}
/**
 * OnEnergyUsageApi - fetch parameter creator
 * @export
 */
export const OnEnergyUsageApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {OnEnergyUsageMeteringPointDeliveryDTO} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onEnergyUsageDeliverMeteringPointResponsePost(
      body?: OnEnergyUsageMeteringPointDeliveryDTO,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/on-energy-usage/deliver-metering-point-response`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"OnEnergyUsageMeteringPointDeliveryDTO" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [periodType]
     * @param {string} [periodIdentifier]
     * @param {string} [periodGranularity]
     * @param {string} [customerSSN]
     * @param {string} [meteringPointIdentifierType]
     * @param {string} [meteringPointIdentifier]
     * @param {string} [dataScope]
     * @param {boolean} [includeChunkUsageBreakdown]
     * @param {boolean} [includeChunkUsageTariffBreakdown]
     * @param {boolean} [includeChunkUsageStatusBreakdown]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onEnergyUsageGetEnergyUsageGet(
      periodType?: string,
      periodIdentifier?: string,
      periodGranularity?: string,
      customerSSN?: string,
      meteringPointIdentifierType?: string,
      meteringPointIdentifier?: string,
      dataScope?: string,
      includeChunkUsageBreakdown?: boolean,
      includeChunkUsageTariffBreakdown?: boolean,
      includeChunkUsageStatusBreakdown?: boolean,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/on-energy-usage/get-energy-usage`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      if (periodType !== undefined) {
        localVarQueryParameter["PeriodType"] = periodType;
      }

      if (periodIdentifier !== undefined) {
        localVarQueryParameter["PeriodIdentifier"] = periodIdentifier;
      }

      if (periodGranularity !== undefined) {
        localVarQueryParameter["PeriodGranularity"] = periodGranularity;
      }

      if (customerSSN !== undefined) {
        localVarQueryParameter["CustomerSSN"] = customerSSN;
      }

      if (meteringPointIdentifierType !== undefined) {
        localVarQueryParameter["MeteringPointIdentifierType"] =
          meteringPointIdentifierType;
      }

      if (meteringPointIdentifier !== undefined) {
        localVarQueryParameter["MeteringPointIdentifier"] =
          meteringPointIdentifier;
      }

      if (dataScope !== undefined) {
        localVarQueryParameter["DataScope"] = dataScope;
      }

      if (includeChunkUsageBreakdown !== undefined) {
        localVarQueryParameter["IncludeChunkUsageBreakdown"] =
          includeChunkUsageBreakdown;
      }

      if (includeChunkUsageTariffBreakdown !== undefined) {
        localVarQueryParameter["IncludeChunkUsageTariffBreakdown"] =
          includeChunkUsageTariffBreakdown;
      }

      if (includeChunkUsageStatusBreakdown !== undefined) {
        localVarQueryParameter["IncludeChunkUsageStatusBreakdown"] =
          includeChunkUsageStatusBreakdown;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OnEnergyUsageApi - functional programming interface
 * @export
 */
export const OnEnergyUsageApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {OnEnergyUsageMeteringPointDeliveryDTO} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onEnergyUsageDeliverMeteringPointResponsePost(
      body?: OnEnergyUsageMeteringPointDeliveryDTO,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = OnEnergyUsageApiFetchParamCreator(
        configuration
      ).onEnergyUsageDeliverMeteringPointResponsePost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} [periodType]
     * @param {string} [periodIdentifier]
     * @param {string} [periodGranularity]
     * @param {string} [customerSSN]
     * @param {string} [meteringPointIdentifierType]
     * @param {string} [meteringPointIdentifier]
     * @param {string} [dataScope]
     * @param {boolean} [includeChunkUsageBreakdown]
     * @param {boolean} [includeChunkUsageTariffBreakdown]
     * @param {boolean} [includeChunkUsageStatusBreakdown]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onEnergyUsageGetEnergyUsageGet(
      periodType?: string,
      periodIdentifier?: string,
      periodGranularity?: string,
      customerSSN?: string,
      meteringPointIdentifierType?: string,
      meteringPointIdentifier?: string,
      dataScope?: string,
      includeChunkUsageBreakdown?: boolean,
      includeChunkUsageTariffBreakdown?: boolean,
      includeChunkUsageStatusBreakdown?: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = OnEnergyUsageApiFetchParamCreator(
        configuration
      ).onEnergyUsageGetEnergyUsageGet(
        periodType,
        periodIdentifier,
        periodGranularity,
        customerSSN,
        meteringPointIdentifierType,
        meteringPointIdentifier,
        dataScope,
        includeChunkUsageBreakdown,
        includeChunkUsageTariffBreakdown,
        includeChunkUsageStatusBreakdown,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * OnEnergyUsageApi - factory interface
 * @export
 */
export const OnEnergyUsageApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {OnEnergyUsageMeteringPointDeliveryDTO} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onEnergyUsageDeliverMeteringPointResponsePost(
      body?: OnEnergyUsageMeteringPointDeliveryDTO,
      options?: any
    ) {
      return OnEnergyUsageApiFp(
        configuration
      ).onEnergyUsageDeliverMeteringPointResponsePost(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {string} [periodType]
     * @param {string} [periodIdentifier]
     * @param {string} [periodGranularity]
     * @param {string} [customerSSN]
     * @param {string} [meteringPointIdentifierType]
     * @param {string} [meteringPointIdentifier]
     * @param {string} [dataScope]
     * @param {boolean} [includeChunkUsageBreakdown]
     * @param {boolean} [includeChunkUsageTariffBreakdown]
     * @param {boolean} [includeChunkUsageStatusBreakdown]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onEnergyUsageGetEnergyUsageGet(
      periodType?: string,
      periodIdentifier?: string,
      periodGranularity?: string,
      customerSSN?: string,
      meteringPointIdentifierType?: string,
      meteringPointIdentifier?: string,
      dataScope?: string,
      includeChunkUsageBreakdown?: boolean,
      includeChunkUsageTariffBreakdown?: boolean,
      includeChunkUsageStatusBreakdown?: boolean,
      options?: any
    ) {
      return OnEnergyUsageApiFp(configuration).onEnergyUsageGetEnergyUsageGet(
        periodType,
        periodIdentifier,
        periodGranularity,
        customerSSN,
        meteringPointIdentifierType,
        meteringPointIdentifier,
        dataScope,
        includeChunkUsageBreakdown,
        includeChunkUsageTariffBreakdown,
        includeChunkUsageStatusBreakdown,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * OnEnergyUsageApi - object-oriented interface
 * @export
 * @class OnEnergyUsageApi
 * @extends {BaseAPI}
 */
export class OnEnergyUsageApi extends BaseAPI {
  /**
   *
   * @param {OnEnergyUsageMeteringPointDeliveryDTO} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OnEnergyUsageApi
   */
  public onEnergyUsageDeliverMeteringPointResponsePost(
    body?: OnEnergyUsageMeteringPointDeliveryDTO,
    options?: any
  ) {
    return OnEnergyUsageApiFp(
      this.configuration
    ).onEnergyUsageDeliverMeteringPointResponsePost(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {string} [periodType]
   * @param {string} [periodIdentifier]
   * @param {string} [periodGranularity]
   * @param {string} [customerSSN]
   * @param {string} [meteringPointIdentifierType]
   * @param {string} [meteringPointIdentifier]
   * @param {string} [dataScope]
   * @param {boolean} [includeChunkUsageBreakdown]
   * @param {boolean} [includeChunkUsageTariffBreakdown]
   * @param {boolean} [includeChunkUsageStatusBreakdown]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OnEnergyUsageApi
   */
  public onEnergyUsageGetEnergyUsageGet(
    periodType?: string,
    periodIdentifier?: string,
    periodGranularity?: string,
    customerSSN?: string,
    meteringPointIdentifierType?: string,
    meteringPointIdentifier?: string,
    dataScope?: string,
    includeChunkUsageBreakdown?: boolean,
    includeChunkUsageTariffBreakdown?: boolean,
    includeChunkUsageStatusBreakdown?: boolean,
    options?: any
  ) {
    return OnEnergyUsageApiFp(
      this.configuration
    ).onEnergyUsageGetEnergyUsageGet(
      periodType,
      periodIdentifier,
      periodGranularity,
      customerSSN,
      meteringPointIdentifierType,
      meteringPointIdentifier,
      dataScope,
      includeChunkUsageBreakdown,
      includeChunkUsageTariffBreakdown,
      includeChunkUsageStatusBreakdown,
      options
    )(this.fetch, this.basePath);
  }
}
/**
 * OnHomechargeApi - fetch parameter creator
 * @export
 */
export const OnHomechargeApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onHomeChargeGetOrderApartmentComplexFoundationFormInitialDataGet(
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/on-home-charge/get-order-apartment-complex-foundation-form-initial-data`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onHomeChargeGetOrderApartmentFormInitialDataGet(
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/on-home-charge/get-order-apartment-form-initial-data`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onHomeChargeGetOrderCompanyFoundationFormInitialDataGet(
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/on-home-charge/get-order-company-foundation-form-initial-data`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onHomeChargeGetOrderHouseFormInitialDataGet(options: any = {}): FetchArgs {
      const localVarPath = `/on-home-charge/get-order-house-form-initial-data`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {OrderApartmentComplexFoundationSubmittedData} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onHomeChargeSubmitOrderApartmentComplexFoundationFormDataPost(
      body?: OrderApartmentComplexFoundationSubmittedData,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/on-home-charge/submit-order-apartment-complex-foundation-form-data`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"OrderApartmentComplexFoundationSubmittedData" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {OrderApartmentSubmittedData} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onHomeChargeSubmitOrderApartmentFormDataPost(
      body?: OrderApartmentSubmittedData,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/on-home-charge/submit-order-apartment-form-data`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"OrderApartmentSubmittedData" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {OrderCompanyFoundationSubmittedData} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onHomeChargeSubmitOrderCompanyFoundationFormDataPost(
      body?: OrderCompanyFoundationSubmittedData,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/on-home-charge/submit-order-company-foundation-form-data`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"OrderCompanyFoundationSubmittedData" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {OrderHouseSubmittedData} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onHomeChargeSubmitOrderHouseFormDataPost(
      body?: OrderHouseSubmittedData,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/on-home-charge/submit-order-house-form-data`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"OrderHouseSubmittedData" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OnHomechargeApi - functional programming interface
 * @export
 */
export const OnHomechargeApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onHomeChargeGetOrderApartmentComplexFoundationFormInitialDataGet(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs =
        OnHomechargeApiFetchParamCreator(
          configuration
        ).onHomeChargeGetOrderApartmentComplexFoundationFormInitialDataGet(
          options
        );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onHomeChargeGetOrderApartmentFormInitialDataGet(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs =
        OnHomechargeApiFetchParamCreator(
          configuration
        ).onHomeChargeGetOrderApartmentFormInitialDataGet(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onHomeChargeGetOrderCompanyFoundationFormInitialDataGet(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs =
        OnHomechargeApiFetchParamCreator(
          configuration
        ).onHomeChargeGetOrderCompanyFoundationFormInitialDataGet(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onHomeChargeGetOrderHouseFormInitialDataGet(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs =
        OnHomechargeApiFetchParamCreator(
          configuration
        ).onHomeChargeGetOrderHouseFormInitialDataGet(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {OrderApartmentComplexFoundationSubmittedData} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onHomeChargeSubmitOrderApartmentComplexFoundationFormDataPost(
      body?: OrderApartmentComplexFoundationSubmittedData,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = OnHomechargeApiFetchParamCreator(
        configuration
      ).onHomeChargeSubmitOrderApartmentComplexFoundationFormDataPost(
        body,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {OrderApartmentSubmittedData} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onHomeChargeSubmitOrderApartmentFormDataPost(
      body?: OrderApartmentSubmittedData,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = OnHomechargeApiFetchParamCreator(
        configuration
      ).onHomeChargeSubmitOrderApartmentFormDataPost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {OrderCompanyFoundationSubmittedData} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onHomeChargeSubmitOrderCompanyFoundationFormDataPost(
      body?: OrderCompanyFoundationSubmittedData,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = OnHomechargeApiFetchParamCreator(
        configuration
      ).onHomeChargeSubmitOrderCompanyFoundationFormDataPost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {OrderHouseSubmittedData} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onHomeChargeSubmitOrderHouseFormDataPost(
      body?: OrderHouseSubmittedData,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = OnHomechargeApiFetchParamCreator(
        configuration
      ).onHomeChargeSubmitOrderHouseFormDataPost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * OnHomechargeApi - factory interface
 * @export
 */
export const OnHomechargeApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onHomeChargeGetOrderApartmentComplexFoundationFormInitialDataGet(
      options?: any
    ) {
      return OnHomechargeApiFp(
        configuration
      ).onHomeChargeGetOrderApartmentComplexFoundationFormInitialDataGet(
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onHomeChargeGetOrderApartmentFormInitialDataGet(options?: any) {
      return OnHomechargeApiFp(
        configuration
      ).onHomeChargeGetOrderApartmentFormInitialDataGet(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onHomeChargeGetOrderCompanyFoundationFormInitialDataGet(options?: any) {
      return OnHomechargeApiFp(
        configuration
      ).onHomeChargeGetOrderCompanyFoundationFormInitialDataGet(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onHomeChargeGetOrderHouseFormInitialDataGet(options?: any) {
      return OnHomechargeApiFp(
        configuration
      ).onHomeChargeGetOrderHouseFormInitialDataGet(options)(fetch, basePath);
    },
    /**
     *
     * @param {OrderApartmentComplexFoundationSubmittedData} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onHomeChargeSubmitOrderApartmentComplexFoundationFormDataPost(
      body?: OrderApartmentComplexFoundationSubmittedData,
      options?: any
    ) {
      return OnHomechargeApiFp(
        configuration
      ).onHomeChargeSubmitOrderApartmentComplexFoundationFormDataPost(
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {OrderApartmentSubmittedData} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onHomeChargeSubmitOrderApartmentFormDataPost(
      body?: OrderApartmentSubmittedData,
      options?: any
    ) {
      return OnHomechargeApiFp(
        configuration
      ).onHomeChargeSubmitOrderApartmentFormDataPost(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {OrderCompanyFoundationSubmittedData} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onHomeChargeSubmitOrderCompanyFoundationFormDataPost(
      body?: OrderCompanyFoundationSubmittedData,
      options?: any
    ) {
      return OnHomechargeApiFp(
        configuration
      ).onHomeChargeSubmitOrderCompanyFoundationFormDataPost(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {OrderHouseSubmittedData} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onHomeChargeSubmitOrderHouseFormDataPost(
      body?: OrderHouseSubmittedData,
      options?: any
    ) {
      return OnHomechargeApiFp(
        configuration
      ).onHomeChargeSubmitOrderHouseFormDataPost(body, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * OnHomechargeApi - object-oriented interface
 * @export
 * @class OnHomechargeApi
 * @extends {BaseAPI}
 */
export class OnHomechargeApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OnHomechargeApi
   */
  public onHomeChargeGetOrderApartmentComplexFoundationFormInitialDataGet(
    options?: any
  ) {
    return OnHomechargeApiFp(
      this.configuration
    ).onHomeChargeGetOrderApartmentComplexFoundationFormInitialDataGet(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OnHomechargeApi
   */
  public onHomeChargeGetOrderApartmentFormInitialDataGet(options?: any) {
    return OnHomechargeApiFp(
      this.configuration
    ).onHomeChargeGetOrderApartmentFormInitialDataGet(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OnHomechargeApi
   */
  public onHomeChargeGetOrderCompanyFoundationFormInitialDataGet(
    options?: any
  ) {
    return OnHomechargeApiFp(
      this.configuration
    ).onHomeChargeGetOrderCompanyFoundationFormInitialDataGet(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OnHomechargeApi
   */
  public onHomeChargeGetOrderHouseFormInitialDataGet(options?: any) {
    return OnHomechargeApiFp(
      this.configuration
    ).onHomeChargeGetOrderHouseFormInitialDataGet(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {OrderApartmentComplexFoundationSubmittedData} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OnHomechargeApi
   */
  public onHomeChargeSubmitOrderApartmentComplexFoundationFormDataPost(
    body?: OrderApartmentComplexFoundationSubmittedData,
    options?: any
  ) {
    return OnHomechargeApiFp(
      this.configuration
    ).onHomeChargeSubmitOrderApartmentComplexFoundationFormDataPost(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {OrderApartmentSubmittedData} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OnHomechargeApi
   */
  public onHomeChargeSubmitOrderApartmentFormDataPost(
    body?: OrderApartmentSubmittedData,
    options?: any
  ) {
    return OnHomechargeApiFp(
      this.configuration
    ).onHomeChargeSubmitOrderApartmentFormDataPost(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {OrderCompanyFoundationSubmittedData} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OnHomechargeApi
   */
  public onHomeChargeSubmitOrderCompanyFoundationFormDataPost(
    body?: OrderCompanyFoundationSubmittedData,
    options?: any
  ) {
    return OnHomechargeApiFp(
      this.configuration
    ).onHomeChargeSubmitOrderCompanyFoundationFormDataPost(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {OrderHouseSubmittedData} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OnHomechargeApi
   */
  public onHomeChargeSubmitOrderHouseFormDataPost(
    body?: OrderHouseSubmittedData,
    options?: any
  ) {
    return OnHomechargeApiFp(
      this.configuration
    ).onHomeChargeSubmitOrderHouseFormDataPost(body, options)(
      this.fetch,
      this.basePath
    );
  }
}
/**
 * OnInvoicesApi - fetch parameter creator
 * @export
 */
export const OnInvoicesApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {BusInvoiceDocumentResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onInvoicesDeliverInvoiceDocumentResponsePost(
      body?: BusInvoiceDocumentResponse,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/on-invoices/deliver-invoice-document-response`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"BusInvoiceDocumentResponse" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {BusInvoicesResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onInvoicesDeliverInvoicesResponsePost(
      body?: BusInvoicesResponse,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/on-invoices/deliver-invoices-response`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"BusInvoicesResponse" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OnInvoicesApi - functional programming interface
 * @export
 */
export const OnInvoicesApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {BusInvoiceDocumentResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onInvoicesDeliverInvoiceDocumentResponsePost(
      body?: BusInvoiceDocumentResponse,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = OnInvoicesApiFetchParamCreator(
        configuration
      ).onInvoicesDeliverInvoiceDocumentResponsePost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {BusInvoicesResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onInvoicesDeliverInvoicesResponsePost(
      body?: BusInvoicesResponse,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = OnInvoicesApiFetchParamCreator(
        configuration
      ).onInvoicesDeliverInvoicesResponsePost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * OnInvoicesApi - factory interface
 * @export
 */
export const OnInvoicesApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {BusInvoiceDocumentResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onInvoicesDeliverInvoiceDocumentResponsePost(
      body?: BusInvoiceDocumentResponse,
      options?: any
    ) {
      return OnInvoicesApiFp(
        configuration
      ).onInvoicesDeliverInvoiceDocumentResponsePost(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {BusInvoicesResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onInvoicesDeliverInvoicesResponsePost(
      body?: BusInvoicesResponse,
      options?: any
    ) {
      return OnInvoicesApiFp(
        configuration
      ).onInvoicesDeliverInvoicesResponsePost(body, options)(fetch, basePath);
    },
  };
};

/**
 * OnInvoicesApi - object-oriented interface
 * @export
 * @class OnInvoicesApi
 * @extends {BaseAPI}
 */
export class OnInvoicesApi extends BaseAPI {
  /**
   *
   * @param {BusInvoiceDocumentResponse} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OnInvoicesApi
   */
  public onInvoicesDeliverInvoiceDocumentResponsePost(
    body?: BusInvoiceDocumentResponse,
    options?: any
  ) {
    return OnInvoicesApiFp(
      this.configuration
    ).onInvoicesDeliverInvoiceDocumentResponsePost(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {BusInvoicesResponse} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OnInvoicesApi
   */
  public onInvoicesDeliverInvoicesResponsePost(
    body?: BusInvoicesResponse,
    options?: any
  ) {
    return OnInvoicesApiFp(
      this.configuration
    ).onInvoicesDeliverInvoicesResponsePost(body, options)(
      this.fetch,
      this.basePath
    );
  }
}
/**
 * OnOceanRouterApi - fetch parameter creator
 * @export
 */
export const OnOceanRouterApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {BusOceanTokenAuthResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onOceanRouterDeliverOceanTokenAuthResponsePost(
      body?: BusOceanTokenAuthResponse,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/on-ocean-router/deliver-ocean-token-auth-response`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"BusOceanTokenAuthResponse" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OnOceanRouterApi - functional programming interface
 * @export
 */
export const OnOceanRouterApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {BusOceanTokenAuthResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onOceanRouterDeliverOceanTokenAuthResponsePost(
      body?: BusOceanTokenAuthResponse,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = OnOceanRouterApiFetchParamCreator(
        configuration
      ).onOceanRouterDeliverOceanTokenAuthResponsePost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * OnOceanRouterApi - factory interface
 * @export
 */
export const OnOceanRouterApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {BusOceanTokenAuthResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onOceanRouterDeliverOceanTokenAuthResponsePost(
      body?: BusOceanTokenAuthResponse,
      options?: any
    ) {
      return OnOceanRouterApiFp(
        configuration
      ).onOceanRouterDeliverOceanTokenAuthResponsePost(body, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * OnOceanRouterApi - object-oriented interface
 * @export
 * @class OnOceanRouterApi
 * @extends {BaseAPI}
 */
export class OnOceanRouterApi extends BaseAPI {
  /**
   *
   * @param {BusOceanTokenAuthResponse} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OnOceanRouterApi
   */
  public onOceanRouterDeliverOceanTokenAuthResponsePost(
    body?: BusOceanTokenAuthResponse,
    options?: any
  ) {
    return OnOceanRouterApiFp(
      this.configuration
    ).onOceanRouterDeliverOceanTokenAuthResponsePost(body, options)(
      this.fetch,
      this.basePath
    );
  }
}
/**
 * OnPaymentsApi - fetch parameter creator
 * @export
 */
export const OnPaymentsApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {OnPaymentsSetSimplePaymentMethodRequestPayload} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onPaymentsCustomerSetSimplePaymentMethodPost(
      body?: OnPaymentsSetSimplePaymentMethodRequestPayload,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/on-payments/customer-set-simple-payment-method`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"OnPaymentsSetSimplePaymentMethodRequestPayload" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {BusOnPaymentsGetCheckoutPageResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onPaymentsDeliverGetCardRegistrationFormInfoResponsePost(
      body?: BusOnPaymentsGetCheckoutPageResponse,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/on-payments/deliver-get-card-registration-form-info-response`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"BusOnPaymentsGetCheckoutPageResponse" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {OnPaymentsGetCustomerResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onPaymentsDeliverGetCustomerResponsePost(
      body?: OnPaymentsGetCustomerResponse,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/on-payments/deliver-get-customer-response`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"OnPaymentsGetCustomerResponse" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {BusOnPaymentsGetResultForCheckoutPageResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onPaymentsDeliverGetResultForCheckoutPageResponsePost(
      body?: BusOnPaymentsGetResultForCheckoutPageResponse,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/on-payments/deliver-get-result-for-checkout-page-response`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"BusOnPaymentsGetResultForCheckoutPageResponse" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OnPaymentsApi - functional programming interface
 * @export
 */
export const OnPaymentsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {OnPaymentsSetSimplePaymentMethodRequestPayload} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onPaymentsCustomerSetSimplePaymentMethodPost(
      body?: OnPaymentsSetSimplePaymentMethodRequestPayload,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = OnPaymentsApiFetchParamCreator(
        configuration
      ).onPaymentsCustomerSetSimplePaymentMethodPost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {BusOnPaymentsGetCheckoutPageResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onPaymentsDeliverGetCardRegistrationFormInfoResponsePost(
      body?: BusOnPaymentsGetCheckoutPageResponse,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = OnPaymentsApiFetchParamCreator(
        configuration
      ).onPaymentsDeliverGetCardRegistrationFormInfoResponsePost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {OnPaymentsGetCustomerResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onPaymentsDeliverGetCustomerResponsePost(
      body?: OnPaymentsGetCustomerResponse,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = OnPaymentsApiFetchParamCreator(
        configuration
      ).onPaymentsDeliverGetCustomerResponsePost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {BusOnPaymentsGetResultForCheckoutPageResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onPaymentsDeliverGetResultForCheckoutPageResponsePost(
      body?: BusOnPaymentsGetResultForCheckoutPageResponse,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = OnPaymentsApiFetchParamCreator(
        configuration
      ).onPaymentsDeliverGetResultForCheckoutPageResponsePost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * OnPaymentsApi - factory interface
 * @export
 */
export const OnPaymentsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {OnPaymentsSetSimplePaymentMethodRequestPayload} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onPaymentsCustomerSetSimplePaymentMethodPost(
      body?: OnPaymentsSetSimplePaymentMethodRequestPayload,
      options?: any
    ) {
      return OnPaymentsApiFp(
        configuration
      ).onPaymentsCustomerSetSimplePaymentMethodPost(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {BusOnPaymentsGetCheckoutPageResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onPaymentsDeliverGetCardRegistrationFormInfoResponsePost(
      body?: BusOnPaymentsGetCheckoutPageResponse,
      options?: any
    ) {
      return OnPaymentsApiFp(
        configuration
      ).onPaymentsDeliverGetCardRegistrationFormInfoResponsePost(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {OnPaymentsGetCustomerResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onPaymentsDeliverGetCustomerResponsePost(
      body?: OnPaymentsGetCustomerResponse,
      options?: any
    ) {
      return OnPaymentsApiFp(
        configuration
      ).onPaymentsDeliverGetCustomerResponsePost(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {BusOnPaymentsGetResultForCheckoutPageResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    onPaymentsDeliverGetResultForCheckoutPageResponsePost(
      body?: BusOnPaymentsGetResultForCheckoutPageResponse,
      options?: any
    ) {
      return OnPaymentsApiFp(
        configuration
      ).onPaymentsDeliverGetResultForCheckoutPageResponsePost(body, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * OnPaymentsApi - object-oriented interface
 * @export
 * @class OnPaymentsApi
 * @extends {BaseAPI}
 */
export class OnPaymentsApi extends BaseAPI {
  /**
   *
   * @param {OnPaymentsSetSimplePaymentMethodRequestPayload} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OnPaymentsApi
   */
  public onPaymentsCustomerSetSimplePaymentMethodPost(
    body?: OnPaymentsSetSimplePaymentMethodRequestPayload,
    options?: any
  ) {
    return OnPaymentsApiFp(
      this.configuration
    ).onPaymentsCustomerSetSimplePaymentMethodPost(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {BusOnPaymentsGetCheckoutPageResponse} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OnPaymentsApi
   */
  public onPaymentsDeliverGetCardRegistrationFormInfoResponsePost(
    body?: BusOnPaymentsGetCheckoutPageResponse,
    options?: any
  ) {
    return OnPaymentsApiFp(
      this.configuration
    ).onPaymentsDeliverGetCardRegistrationFormInfoResponsePost(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {OnPaymentsGetCustomerResponse} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OnPaymentsApi
   */
  public onPaymentsDeliverGetCustomerResponsePost(
    body?: OnPaymentsGetCustomerResponse,
    options?: any
  ) {
    return OnPaymentsApiFp(
      this.configuration
    ).onPaymentsDeliverGetCustomerResponsePost(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {BusOnPaymentsGetResultForCheckoutPageResponse} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OnPaymentsApi
   */
  public onPaymentsDeliverGetResultForCheckoutPageResponsePost(
    body?: BusOnPaymentsGetResultForCheckoutPageResponse,
    options?: any
  ) {
    return OnPaymentsApiFp(
      this.configuration
    ).onPaymentsDeliverGetResultForCheckoutPageResponsePost(body, options)(
      this.fetch,
      this.basePath
    );
  }
}
/**
 * SwitchONApi - fetch parameter creator
 * @export
 */
export const SwitchONApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {ORECSIMLoginResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    switchonDeliverLoginResponsePost(
      body?: ORECSIMLoginResponse,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/switchon/deliver-login-response`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"ORECSIMLoginResponse" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {BusPropertiesResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    switchonDeliverPropertiesResponsePost(
      body?: BusPropertiesResponse,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/switchon/deliver-properties-response`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"BusPropertiesResponse" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {OnboardingSubmittedData} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    switchonSubmitOnboardingDataPost(
      body?: OnboardingSubmittedData,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/switchon/submit-onboarding-data`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"OnboardingSubmittedData" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SwitchONApi - functional programming interface
 * @export
 */
export const SwitchONApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {ORECSIMLoginResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    switchonDeliverLoginResponsePost(
      body?: ORECSIMLoginResponse,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = SwitchONApiFetchParamCreator(
        configuration
      ).switchonDeliverLoginResponsePost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {BusPropertiesResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    switchonDeliverPropertiesResponsePost(
      body?: BusPropertiesResponse,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = SwitchONApiFetchParamCreator(
        configuration
      ).switchonDeliverPropertiesResponsePost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {OnboardingSubmittedData} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    switchonSubmitOnboardingDataPost(
      body?: OnboardingSubmittedData,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = SwitchONApiFetchParamCreator(
        configuration
      ).switchonSubmitOnboardingDataPost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * SwitchONApi - factory interface
 * @export
 */
export const SwitchONApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {ORECSIMLoginResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    switchonDeliverLoginResponsePost(
      body?: ORECSIMLoginResponse,
      options?: any
    ) {
      return SwitchONApiFp(configuration).switchonDeliverLoginResponsePost(
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {BusPropertiesResponse} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    switchonDeliverPropertiesResponsePost(
      body?: BusPropertiesResponse,
      options?: any
    ) {
      return SwitchONApiFp(configuration).switchonDeliverPropertiesResponsePost(
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {OnboardingSubmittedData} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    switchonSubmitOnboardingDataPost(
      body?: OnboardingSubmittedData,
      options?: any
    ) {
      return SwitchONApiFp(configuration).switchonSubmitOnboardingDataPost(
        body,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * SwitchONApi - object-oriented interface
 * @export
 * @class SwitchONApi
 * @extends {BaseAPI}
 */
export class SwitchONApi extends BaseAPI {
  /**
   *
   * @param {ORECSIMLoginResponse} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SwitchONApi
   */
  public switchonDeliverLoginResponsePost(
    body?: ORECSIMLoginResponse,
    options?: any
  ) {
    return SwitchONApiFp(this.configuration).switchonDeliverLoginResponsePost(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {BusPropertiesResponse} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SwitchONApi
   */
  public switchonDeliverPropertiesResponsePost(
    body?: BusPropertiesResponse,
    options?: any
  ) {
    return SwitchONApiFp(
      this.configuration
    ).switchonDeliverPropertiesResponsePost(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {OnboardingSubmittedData} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SwitchONApi
   */
  public switchonSubmitOnboardingDataPost(
    body?: OnboardingSubmittedData,
    options?: any
  ) {
    return SwitchONApiFp(this.configuration).switchonSubmitOnboardingDataPost(
      body,
      options
    )(this.fetch, this.basePath);
  }
}
/**
 * UtilsApi - fetch parameter creator
 * @export
 */
export const UtilsApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilsHealthGet(options: any = {}): FetchArgs {
      const localVarPath = `/utils/health`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilsWhoAmIGet(options: any = {}): FetchArgs {
      const localVarPath = `/utils/who-am-i`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilsWhoAmIOnGet(options: any = {}): FetchArgs {
      const localVarPath = `/utils/who-am-i-on`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ONToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      // authentication SharedSecret required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UtilsApi - functional programming interface
 * @export
 */
export const UtilsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilsHealthGet(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs =
        UtilsApiFetchParamCreator(configuration).utilsHealthGet(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilsWhoAmIGet(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UserInfo> {
      const localVarFetchArgs =
        UtilsApiFetchParamCreator(configuration).utilsWhoAmIGet(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilsWhoAmIOnGet(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UserInfo> {
      const localVarFetchArgs =
        UtilsApiFetchParamCreator(configuration).utilsWhoAmIOnGet(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * UtilsApi - factory interface
 * @export
 */
export const UtilsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilsHealthGet(options?: any) {
      return UtilsApiFp(configuration).utilsHealthGet(options)(fetch, basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilsWhoAmIGet(options?: any) {
      return UtilsApiFp(configuration).utilsWhoAmIGet(options)(fetch, basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilsWhoAmIOnGet(options?: any) {
      return UtilsApiFp(configuration).utilsWhoAmIOnGet(options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * UtilsApi - object-oriented interface
 * @export
 * @class UtilsApi
 * @extends {BaseAPI}
 */
export class UtilsApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public utilsHealthGet(options?: any) {
    return UtilsApiFp(this.configuration).utilsHealthGet(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public utilsWhoAmIGet(options?: any) {
    return UtilsApiFp(this.configuration).utilsWhoAmIGet(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public utilsWhoAmIOnGet(options?: any) {
    return UtilsApiFp(this.configuration).utilsWhoAmIOnGet(options)(
      this.fetch,
      this.basePath
    );
  }
}
